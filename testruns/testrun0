Testing, testing
init'd
Got: Load "/home/izzy/prog/slick/Foo.hs"
These be the argHoles:fromList []
Giving: Ok
Got: Search "[IO Int] -> IO [String]"
length moveSeqs = 6723
# distinct move seqs = 6723
size gs = 2115
Giving: SetInfoWindow "(fmap . fmap) (\\x -> shows  x _) . sequence\nfmap (words . (\\x -> showList  x _)) . sequence\nfmap (lines . (\\x -> shows  x _)) . sequence_\nfmap (words . (\\x -> shows  x _)) . sequence_\n(fmap . fmap) (\\x -> shows  x _) . sequence . fmap void\nfmap (fmap (\\x -> shows  x _) . void) . sequence\nfmap (lines . (\\x -> showList  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . fromEnum) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . Signal) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . odd) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . Signal) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . toInteger) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . even) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . toEnum) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . fromIntegral) . sequence\nfmap (words . (\\x -> shows  x _) . fromEnum) . sequence_\nfmap (concat . fmap lines . fmap (\\x -> shows  x _)) . sequence\nfmap (lines . (\\x -> showList  x _) . fmap toInteger) . sequence\nfmap (words . (\\x -> showList  x _) . fmap toEnum) . sequence\nfmap (words . (\\x -> shows  x _)) . print . null\nfmap (words . (\\x -> shows  x _)) . void . sequence\nfmap (fmap ((\\x -> shows  x _) . fromEnum) . void) . sequence\nfmap (concat . fmap words . fmap (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . fromEnum) . sequence . fmap void\nfmap (words . (\\x -> shows  x _)) . void . sequence_\nfmap (lines . (\\x -> showList  x _) . void) . sequence\nfmap (lines . (\\x -> showList  x _) . fmap fromEnum) . sequence\nfmap (fmap (\\x -> shows  x _) . void . void) . sequence\nfmap (join . fmap lines . fmap (\\x -> shows  x _)) . sequence\nfmap lines . readFile . (\\x -> shows  x _) . null\nfmap (words . (\\x -> showList  x _) . void) . sequence\nfmap (lines . (\\x -> shows  x _)) . print . length\nfmap (join . fmap words . fmap (\\x -> shows  x _)) . sequence\nfmap words . readFile . (\\x -> shows  x _) . null\nfmap (lines . (\\x -> shows  x _)) . sequence_ . listToMaybe\nfmap (lines . (\\x -> shows  x _) . length) . sequence\nfmap (words . (\\x -> showList  x _) . fmap toInteger) . sequence\nfmap lines . readFile . (\\x -> showList  x _) . void\nfmap (lines . (\\x -> showList  x _) . fmap Signal) . sequence\nfmap (lines . (\\x -> showList  x _) . fmap even) . sequence\nfmap (lines . (\\x -> showList  x _) . fmap fromIntegral) . sequence\nfmap (words . (\\x -> shows  x _)) . print . length\nfmap (words . (\\x -> shows  x _)) . sequence_ . listToMaybe\nfmap (lines . (\\x -> shows  x _)) . sequence_ . fmap void\nfmap (words . (\\x -> shows  x _) . length) . sequence\nfmap lines . readFile . (\\x -> shows  x _) . length\nfmap (fmap (\\x -> shows  x _) . void) . sequence . fmap void\nfmap (words . (\\x -> shows  x _) . sum) . sequence\n(fmap . fmap) (\\x -> shows  x _) . sequence . fmap join . (fmap . fmap) print\n(fmap . fmap) (\\x -> shows  x _) . sequence . fmap print . void\nfmap words . readFile . (\\x -> showList  x _) . void\nfmap (words . (\\x -> showList  x _) . fmap odd) . sequence\nfmap (words . (\\x -> showList  x _) . fmap fromEnum) . sequence\nfmap (lines . (\\x -> shows  x _)) . sequence_ . PrefixPatSyn\nfmap (lines . (\\x -> shows  x _) . null) . sequence\nfmap (lines . (\\x -> showList  x _)) . sequence . fmap void\nfmap (lines . (\\x -> shows  x _) . sum) . sequence\nfmap (lines . (\\x -> showList  x _) . fmap odd) . sequence\nfmap (words . (\\x -> shows  x _)) . sequence_ . fmap void\nfmap words . readFile . (\\x -> shows  x _) . length\nfmap (words . (\\x -> shows  x _)) . sequence_ . PrefixPatSyn\nfmap (lines . (\\x -> showList  x _) . fmap toEnum) . sequence\nfmap (words . (\\x -> shows  x _) . null) . sequence\nfmap (lines . (\\x -> shows  x _)) . void . sequence_\nfmap (words . (\\x -> showList  x _)) . sequence . fmap void\n(fmap . fmap) (\\x -> shows  x _) . sequence . fmap void . fmap void\nfmap (words . (\\x -> showList  x _) . fmap fromIntegral) . sequence\nsequence . fmap join . (fmap . fmap) readFile . (fmap . fmap) (\\x -> shows  x _)\nfmap (words . (\\x -> showList  x _) . fmap Signal) . sequence\nfmap (words . (\\x -> showList  x _) . fmap even) . sequence\nfmap (lines . (\\x -> shows  x _) . fromEnum) . sequence_\nfmap (lines . (\\x -> shows  x _)) . print . null\nsequence . fmap readFile . fmap (\\x -> shows  x _) . void\nfmap (lines . (\\x -> shows  x _)) . void . sequence\n(fmap . fmap) (unwords . lines . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . even . toInteger) . sequence\n(fmap . fmap) (unlines . words . (\\x -> shows  x _)) . sequence\n(fmap . fmap) (\\x -> shows  x _) . sequence . maybeToList . listToMaybe\n(fmap . fmap) ((\\x -> shows  x _) . fromIntegral . fromEnum) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . even . fromIntegral) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . Signal . fromEnum) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . fromEnum . even) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . even . toEnum) . sequence\nfmap (fmap (\\x -> shows  x _) . maybeToList . listToMaybe) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . toInteger . fromEnum) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . fromEnum . toEnum) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . fromEnum . fromIntegral) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . even . fromEnum) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . toInteger . toEnum) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . toInteger . fromIntegral) . sequence\n(fmap . fmap) (unwords . words . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . odd . fromEnum) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . Signal . fromEnum) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . odd . toInteger) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . odd . fromIntegral) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . odd . toEnum) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . toInteger . toInteger) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . toEnum . fromEnum) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . fromIntegral . fromIntegral) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . fromEnum . fromEnum) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . fromIntegral . toEnum) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . f . even) . sequence\n(fmap . fmap) (unlines . lines . (\\x -> shows  x _)) . sequence\nfmap (fmap (\\x -> shows  x _) . maybeToList) . sequence . listToMaybe\n(fmap . fmap) ((\\x -> shows  x _) . f . odd) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . fromEnum . toInteger) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . fromIntegral . toInteger) . sequence\n(fmap . fmap) (moduleNameString . mkModuleName . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . fromEnum . odd) . sequence\n(fmap . fmap) (\\x -> showsPrec _ x _) . sequence\n(fmap . fmap) (\\x -> showsPrec  x _ _) . sequence\nfmap (fmap (\\x -> showList  x _) . replicateM _) . sequence\n(fmap . fmap) (\\x -> showList  x _) . sequence . fmap (replicateM _)\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThen  x _)) . sequence_\n(fmap . fmap) (\\x -> shows  x _) . replicateM _ . sequence_\nfmap (lines . (\\x -> showsPrec _ x _)) . sequence_\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromTo  x _)) . sequence_\nfmap (words . (\\x -> showsPrec _ x _)) . sequence_\n(fmap . fmap) (\\x -> shows  x _) . sequence . fmap (replicateM_ _)\nfmap (fmap (\\x -> shows  x _) . enumFromThen _) . sequence_\nfmap (fmap (\\x -> shows  x _) . replicateM_ _) . sequence\n(fmap . fmap) (\\x -> showList  x _) . replicateM _ . sequence\nfmap (fmap (\\x -> shows  x _) . enumFromTo _) . sequence_\n(fmap . fmap) (\\x -> showsPrec _ x _) . sequence . fmap void\nfmap (fmap (\\x -> showsPrec _ x _) . void) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . odd) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . fromEnum) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . Signal) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . fromEnum) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . enumFromTo _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . toInteger) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . fromIntegral) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . toEnum) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . odd) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . enumFromThen _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . even) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . (\\x -> AnnDocSection  x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . even) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromTo  x _)) . sequence . fmap void\n(fmap . fmap) ((\\x -> showList  x _) . fmap fromEnum) . sequence . fmap (replicateM _)\nfmap (fmap (\\x -> showList  x _) . sequence . fmap (enumFromThen _)) . sequence\nfmap (fmap ((\\x -> showList  x _) . fmap Signal) . replicateM _) . sequence\nfmap (fmap ((\\x -> shows  x _) . fromEnum) . (\\x -> enumFromTo  x _)) . sequence_\nfmap (words . (\\x -> showsPrec _ x _)) . sequence_ . PrefixPatSyn\nfmap (fmap ((\\x -> showList  x _) . fmap fromEnum) . replicateM _) . sequence\nfmap (fmap (\\x -> shows  x _) . enumFromTo _ . fromEnum) . sequence_\nfmap (fmap ((\\x -> showList  x _) . (\\x -> enumFromTo  x _)) . void) . sequence\nfmap (words . (\\x -> showList  x _) . fmap (\\x -> scaleFloat  x _)) . sequence\nfmap words . readFile . (\\x -> showParen  x _ _) . null\nfmap (fmap ((\\x -> shows  x _) . null) . userHsTyVarBndrs _) . sequence\nfmap (fmap (\\x -> shows  x _) . void) . sequence . fmap (replicateM _)\n(fmap . fmap) (\\x -> shows  x _) . sequence . fmap void . fmap (replicateM _)\nfmap (fmap ((\\x -> showList  x _) . fmap toEnum) . replicateM _) . sequence\nfmap (lines . (\\x -> shows  x _) . all _) . sequence\nfmap (fmap (\\x -> shows  x _) . void . replicateM _) . sequence\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThen  x _)) . void . sequence_\nfmap (words . (\\x -> shows  x _)) . replicateM_ _ . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap Signal) . sequence . fmap (replicateM _)\nfmap (lines . (\\x -> showList  x _) . (\\x -> enumFromTo  x _)) . sequence_\n(fmap . fmap) ((\\x -> showList  x _) . fmap toEnum) . sequence . fmap (replicateM _)\n(fmap . fmap) ((\\x -> showList  x _) . fmap fromIntegral) . replicateM _ . sequence\n(fmap . fmap) ((\\x -> showList  x _) . void) . sequence . fmap (replicateM _)\nfmap (words . (\\x -> showList  x _) . (\\x -> showList  x _)) . sequence\nfmap (fmap ((\\x -> showList  x _) . void) . replicateM _) . sequence\n(fmap . fmap) (\\x -> showsPrec _ x _) . sequence . fmap join . (fmap . fmap) print\n(fmap . fmap) ((\\x -> showList  x _) . fmap odd) . replicateM _ . sequence\nfmap (fmap (\\x -> shows  x _) . enumFromThen _) . void . sequence_\n(fmap . fmap) (unlines . fmap (\\x -> shows  x _)) . replicateM _ . sequence\nreplicateM _ . readFile . (\\x -> shows  x _) . null\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromTo  x _)) . void . sequence\nfmap (fmap (\\x -> shows  x _) . enumFromTo _ . null) . sequence\n(fmap . fmap) (\\x -> shows  x _) . replicateM _ . sequence_ . fmap void\nfmap (fmap (\\x -> showList  x _) . replicateM _ . void) . sequence\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromTo  x _)) . print . null\nfmap (concat . fmap lines . fmap (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) (\\x -> showList  x _) . replicateM _ . sequence . fmap void\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThen  x _) . length) . sequence\nfmap (lines . (\\x -> showsPrec _ x _) . length) . sequence\nfmap (fmap (\\x -> shows  x _) . enumFromThen _ . length) . sequence\nfmap (words . (\\x -> showList  x _) . (\\x -> enumFromTo  x _)) . sequence_\nfmap (lines . (\\x -> showsPrec _ x _)) . print . length\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThen  x _)) . sequence_ . listToMaybe\nfmap (fmap (\\x -> shows  x _) . void . (\\x -> enumFromTo  x _)) . sequence_\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThen  x _) . null) . sequence\nfmap (fmap (\\x -> shows  x _) . sequence_) . replicateM _ . sequence\nfmap (lines . (\\x -> showList  x _) . (\\x -> shows  x _)) . sequence_\nfmap (words . (\\x -> shows  x _) . all _) . sequence\nfmap (fmap (\\x -> shows  x _) . concat . fmap (enumFromTo _)) . sequence\nfmap (lines . (\\x -> showList  x _) . fmap (\\x -> scaleFloat  x _)) . sequence\nfmap (words . (\\x -> showList  x _) . fmap (\\x -> AnnDocSection  x _)) . sequence\nfmap (fmap (\\x -> shows  x _) . sequence_ . break _) . sequence\nfmap (fmap ((\\x -> shows  x _) . sum) . replicateM _) . sequence\nfmap (fmap (\\x -> shows  x _) . join . fmap (\\x -> enumFromThen  x _)) . sequence\nfmap (lines . (\\x -> showsPrec _ x _) . sum) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . sum) . sequence . fmap (replicateM _)\nfmap (words . (\\x -> showsPrec _ x _) . length) . sequence\n(fmap . fmap) (unwords . fmap (\\x -> shows  x _)) . replicateM _ . sequence\n(fmap . fmap) (\\x -> shows  x _) . replicateM _ . sequence_ . listToMaybe\n(fmap . fmap) ((\\x -> shows  x _) . fromEnum) . replicateM _ . sequence_\nfmap (lines . (\\x -> showsPrec _ x _)) . sequence_ . listToMaybe\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThen  x _)) . void . sequence\nfmap (fmap ((\\x -> showList  x _) . fmap toInteger) . replicateM _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . length) . replicateM _ . sequence\nfmap (fmap (\\x -> showList  x _) . sequence . replicateM _) . sequence\nfmap (lines . (\\x -> showList  x _)) . sequence . fmap (replicateM_ _)\nfmap (lines . (\\x -> shows  x _) . any _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap toInteger) . sequence . fmap (replicateM _)\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThen  x _)) . print . null\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromTo  x _)) . sequence_ . listToMaybe\nfmap (words . (\\x -> showList  x _) . (\\x -> shows  x _)) . sequence_\n(fmap . fmap) ((\\x -> showList  x _) . fmap even) . sequence . fmap (replicateM _)\nfmap (fmap ((\\x -> shows  x _) . sum) . zip _) . sequence\nfmap (fmap (\\x -> shows  x _) . enumFromThen _ . sum) . sequence\nfmap (words . (\\x -> showsGot: Load "/home/izzy/prog/slick/Scratch.hs"
These be the argHoles:fromList []
Giving: Error "GHC error: Mote.Holes.getHoleInfos: Illegal instance declaration for \8216MonadUnique (t m)\8217\n  (All instance types must be of the form (T a1 ... an)\n   where a1 ... an are *distinct type variables*,\n   and each type variable appears at most once in the instance head.\n   Use FlexibleInstances if you want to disable this.)\nIn the instance declaration for \8216MonadUnique (t m)\8217"
Got: Load "/home/izzy/prog/slick/Scratch.hs"
These be the argHoles:fromList []
Giving: Error "GHC error: Mote.Holes.getHoleInfos: Illegal instance declaration for \8216MonadUnique (t m)\8217\n  (All instance types must be of the form (T a1 ... an)\n   where a1 ... an are *distinct type variables*,\n   and each type variable appears at most once in the instance head.\n   Use FlexibleInstances if you want to disable this.)\nIn the instance declaration for \8216MonadUnique (t m)\8217"
Got: Load "/home/izzy/prog/slick/Scratch.hs"
These be the argHoles:fromList []
Giving: Error "GHC error: Mote.Holes.getHoleInfos: Illegal instance declaration for \8216MonadUnique (t m)\8217\n  (All instance types must be of the form (T a1 ... an)\n   where a1 ... an are *distinct type variables*,\n   and each type variable appears at most once in the instance head.\n   Use FlexibleInstances if you want to disable this.)\nIn the instance declaration for \8216MonadUnique (t m)\8217"
Got: Load "/home/izzy/prog/slick/Mote.hs"
These be the argHoles:fromList []
Giving: Ok
Got: Load "/home/izzy/prog/slick/Mote.hs"
These be the argHoles:fromList []
Giving: Ok
Got: Load "/home/izzy/prog/slick/Scratch.hs"
These be the argHoles:fromList []
Giving: Error "GHC error: Mote.Holes.getHoleInfos: Illegal instance declaration for \8216MonadUnique (t m)\8217\n  (All instance types must be of the form (T a1 ... an)\n   where a1 ... an are *distinct type variables*,\n   and each type variable appears at most once in the instance head.\n   Use FlexibleInstances if you want to disable this.)\nIn the instance declaration for \8216MonadUnique (t m)\8217"
Got: Load "/home/izzy/prog/slick/Mote.hs"
These be the argHoles:fromList []
Giving: Ok
Got: NextHole (ClientState {path = "/home/izzy/prog/slick/Mote.hs", cursorPos = (232,4)})
Giving: Error "No hole at the current location."
Got: EnterHole (ClientState {path = "/home/izzy/prog/slick/Mote.hs", cursorPos = (232,4)})
Giving: SetInfoWindow "No Hole found"
Got: GetHoleInfo (ClientState {path = "/home/izzy/prog/slick/Mote.hs", cursorPos = (232,4)}) (HoleInfoOptions {sendOutputAsData = False, withSuggestions = False})
Giving: Error "No hole at the current location."
Got: Load "/home/izzy/prog/slick/Mote.hs"
These be the argHoles:fromList []
Giving: Ok
Got: Load "/home/izzy/prog/slick/Search/Graph.hs"
These be the argHoles:fromList []
Giving: Error "GHC error: Mote.Holes.getHoleInfos: Non type-variable argument\n  in the constraint: MArray\n                       a (Map k_a6xbL (HashSet.HashSet [a_a6xbM])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i, MArray a (Map k0 (HashSet.HashSet [a0])) f) =>\n        a i (Map k0 (HashSet.HashSet [a0]))\n        -> i -> k0 -> f (HashSet.HashSet [a0])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo'\8217:\n    moveSequencesOfSizeAtMostMemo' branchOut n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet [Move f o])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray a (Map (Word f o) (HashSet.HashSet [Move f o])) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet [Move f o]))\n        -> i -> Word f o -> f1 (HashSet.HashSet [Move f o])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo\8217:\n    moveSequencesOfSizeAtMostMemo tsList n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostMemo'\8217:\n    graphsOfSizeAtMostMemo' branchOut n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMost\8217:\n    graphsOfSizeAtMost tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i\n        -> Word f o\n        -> Trans f o\n        -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostH\8217:\n    graphsOfSizeAtMostH tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 fmap HashSet.unions . forM (branchOut ts start)\n                 $ \\ (b', move) -> ... }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go _ 0 b _\n            = return\n              $ if b == end then\n                    HashSet.singleton (idGraph end)\n                else\n                    HashSet.empty\n          go arr n b t\n            = do { memo <- readArray arr n;\n                   .... }"
Got: Load "/home/izzy/prog/slick/Search/Graph.hs"
These be the argHoles:fromList []
Giving: Error "GHC error: Mote.Holes.getHoleInfos: Non type-variable argument\n  in the constraint: MArray\n                       a (Map k_a6EIY (HashSet.HashSet [a_a6EIZ])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i, MArray a (Map k0 (HashSet.HashSet [a0])) f) =>\n        a i (Map k0 (HashSet.HashSet [a0]))\n        -> i -> k0 -> f (HashSet.HashSet [a0])\nIn an equation for \8216moveSequencesOfSizeAtMostMemoNotTooHoley'\8217:\n    moveSequencesOfSizeAtMostMemoNotTooHoley' branchOut n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map k_a6EEr (HashSet.HashSet [a_a6EEs])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i, MArray a (Map k0 (HashSet.HashSet [a0])) f) =>\n        a i (Map k0 (HashSet.HashSet [a0]))\n        -> i -> k0 -> f (HashSet.HashSet [a0])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo'\8217:\n    moveSequencesOfSizeAtMostMemo' branchOut n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet [Move f o])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray a (Map (Word f o) (HashSet.HashSet [Move f o])) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet [Move f o]))\n        -> i -> Word f o -> f1 (HashSet.HashSet [Move f o])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo\8217:\n    moveSequencesOfSizeAtMostMemo tsList n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostMemo'\8217:\n    graphsOfSizeAtMostMemo' branchOut n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMost\8217:\n    graphsOfSizeAtMost tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i\n        -> Word f o\n        -> Trans f o\n        -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostH\8217:\n    graphsOfSizeAtMostH tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 fmap HashSet.unions . forM (branchOut ts start)\n                 $ \\ (b', move) -> ... }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go _ 0 b _\n            = return\n              $ if b == end then\n                    HashSet.singleton (idGraph end)\n                else\n                    HashSet.empty\n          go arr n b t\n            = do { memo <- readArray arr n;\n                   .... }"
Got: Load "/home/izzy/prog/slick/Search/Graph.hs"
These be the argHoles:fromList []
Giving: Error "GHC error: Mote.Holes.getHoleInfos: Non type-variable argument\n  in the constraint: MArray\n                       a (Map k_a6Mg8 (HashSet.HashSet [a_a6Mg9])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i, MArray a (Map k0 (HashSet.HashSet [a0])) f) =>\n        a i (Map k0 (HashSet.HashSet [a0]))\n        -> i -> k0 -> f (HashSet.HashSet [a0])\nIn an equation for \8216moveSequencesOfSizeAtMostMemoNotTooHoley'\8217:\n    moveSequencesOfSizeAtMostMemoNotTooHoley' branchOut n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map k_a6MbB (HashSet.HashSet [a_a6MbC])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i, MArray a (Map k0 (HashSet.HashSet [a0])) f) =>\n        a i (Map k0 (HashSet.HashSet [a0]))\n        -> i -> k0 -> f (HashSet.HashSet [a0])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo'\8217:\n    moveSequencesOfSizeAtMostMemo' branchOut n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet [Move f o])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray a (Map (Word f o) (HashSet.HashSet [Move f o])) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet [Move f o]))\n        -> i -> Word f o -> f1 (HashSet.HashSet [Move f o])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo\8217:\n    moveSequencesOfSizeAtMostMemo tsList n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostMemo'\8217:\n    graphsOfSizeAtMostMemo' branchOut n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMost\8217:\n    graphsOfSizeAtMost tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i\n        -> Word f o\n        -> Trans f o\n        -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostH\8217:\n    graphsOfSizeAtMostH tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 fmap HashSet.unions . forM (branchOut ts start)\n                 $ \\ (b', move) -> ... }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go _ 0 b _\n            = return\n              $ if b == end then\n                    HashSet.singleton (idGraph end)\n                else\n                    HashSet.empty\n          go arr n b t\n            = do { memo <- readArray arr n;\n                   .... }"
Got: Load "/home/izzy/prog/slick/Search/Graph.hs"
These be the argHoles:fromList []
Giving: Error "GHC error: Mote.Holes.getHoleInfos: Non type-variable argument\n  in the constraint: MArray\n                       a (Map k_a6TNi (HashSet.HashSet [a_a6TNj])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i, MArray a (Map k0 (HashSet.HashSet [a0])) f) =>\n        a i (Map k0 (HashSet.HashSet [a0]))\n        -> i -> k0 -> f (HashSet.HashSet [a0])\nIn an equation for \8216moveSequencesOfSizeAtMostMemoNotTooHoley'\8217:\n    moveSequencesOfSizeAtMostMemoNotTooHoley' branchOut n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map k_a6TIL (HashSet.HashSet [a_a6TIM])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i, MArray a (Map k0 (HashSet.HashSet [a0])) f) =>\n        a i (Map k0 (HashSet.HashSet [a0]))\n        -> i -> k0 -> f (HashSet.HashSet [a0])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo'\8217:\n    moveSequencesOfSizeAtMostMemo' branchOut n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet [Move f o])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray a (Map (Word f o) (HashSet.HashSet [Move f o])) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet [Move f o]))\n        -> i -> Word f o -> f1 (HashSet.HashSet [Move f o])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo\8217:\n    moveSequencesOfSizeAtMostMemo tsList n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostMemo'\8217:\n    graphsOfSizeAtMostMemo' branchOut n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMost\8217:\n    graphsOfSizeAtMost tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i\n        -> Word f o\n        -> Trans f o\n        -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostH\8217:\n    graphsOfSizeAtMostH tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 fmap HashSet.unions . forM (branchOut ts start)\n                 $ \\ (b', move) -> ... }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go _ 0 b _\n            = return\n              $ if b == end then\n                    HashSet.singleton (idGraph end)\n                else\n                    HashSet.empty\n          go arr n b t\n            = do { memo <- readArray arr n;\n                   .... }"
Got: Load "/home/izzy/prog/slick/Search/Graph.hs"
These be the argHoles:fromList []
Giving: Error "GHC error: Mote.Holes.getHoleInfos: Non type-variable argument\n  in the constraint: MArray\n                       a (Map k_a71ks (HashSet.HashSet [a_a71kt])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i, MArray a (Map k0 (HashSet.HashSet [a0])) f) =>\n        a i (Map k0 (HashSet.HashSet [a0]))\n        -> i -> k0 -> f (HashSet.HashSet [a0])\nIn an equation for \8216moveSequencesOfSizeAtMostMemoNotTooHoley'\8217:\n    moveSequencesOfSizeAtMostMemoNotTooHoley' branchOut n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map k_a71fV (HashSet.HashSet [a_a71fW])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i, MArray a (Map k0 (HashSet.HashSet [a0])) f) =>\n        a i (Map k0 (HashSet.HashSet [a0]))\n        -> i -> k0 -> f (HashSet.HashSet [a0])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo'\8217:\n    moveSequencesOfSizeAtMostMemo' branchOut n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet [Move f o])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray a (Map (Word f o) (HashSet.HashSet [Move f o])) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet [Move f o]))\n        -> i -> Word f o -> f1 (HashSet.HashSet [Move f o])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo\8217:\n    moveSequencesOfSizeAtMostMemo tsList n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostMemo'\8217:\n    graphsOfSizeAtMostMemo' branchOut n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMost\8217:\n    graphsOfSizeAtMost tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i\n        -> Word f o\n        -> Trans f o\n        -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostH\8217:\n    graphsOfSizeAtMostH tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 fmap HashSet.unions . forM (branchOut ts start)\n                 $ \\ (b', move) -> ... }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go _ 0 b _\n            = return\n              $ if b == end then\n                    HashSet.singleton (idGraph end)\n                else\n                    HashSet.empty\n          go arr n b t\n            = do { memo <- readArray arr n;\n                   .... }"
Got: Load "/home/izzy/prog/slick/Scratch.hs"
These be the argHoles:fromList []
Giving: Error "GHC error: Mote.Holes.getHoleInfos: Illegal instance declaration for \8216MonadUnique (t m)\8217\n  (All instance types must be of the form (T a1 ... an)\n   where a1 ... an are *distinct type variables*,\n   and each type variable appears at most once in the instance head.\n   Use FlexibleInstances if you want to disable this.)\nIn the instance declaration for \8216MonadUnique (t m)\8217"
Got: Load "/home/izzy/prog/slick/Search/Graph.hs"
These be the argHoles:fromList []
Giving: Error "GHC error: Mote.Holes.getHoleInfos: Non type-variable argument\n  in the constraint: MArray\n                       a (Map k_a7snf (HashSet.HashSet [a_a7sng])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i, MArray a (Map k0 (HashSet.HashSet [a0])) f) =>\n        a i (Map k0 (HashSet.HashSet [a0]))\n        -> i -> k0 -> f (HashSet.HashSet [a0])\nIn an equation for \8216moveSequencesOfSizeAtMostMemoNotTooHoley'\8217:\n    moveSequencesOfSizeAtMostMemoNotTooHoley' branchOut n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map k_a7siI (HashSet.HashSet [a_a7siJ])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i, MArray a (Map k0 (HashSet.HashSet [a0])) f) =>\n        a i (Map k0 (HashSet.HashSet [a0]))\n        -> i -> k0 -> f (HashSet.HashSet [a0])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo'\8217:\n    moveSequencesOfSizeAtMostMemo' branchOut n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet [Move f o])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray a (Map (Word f o) (HashSet.HashSet [Move f o])) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet [Move f o]))\n        -> i -> Word f o -> f1 (HashSet.HashSet [Move f o])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo\8217:\n    moveSequencesOfSizeAtMostMemo tsList n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostMemo'\8217:\n    graphsOfSizeAtMostMemo' branchOut n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMost\8217:\n    graphsOfSizeAtMost tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i\n        -> Word f o\n        -> Trans f o\n        -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostH\8217:\n    graphsOfSizeAtMostH tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 fmap HashSet.unions . forM (branchOut ts start)\n                 $ \\ (b', move) -> ... }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go _ 0 b _\n            = return\n              $ if b == end then\n                    HashSet.singleton (idGraph end)\n                else\n                    HashSet.empty\n          go arr n b t\n            = do { memo <- readArray arr n;\n                   .... }"
Got: Load "/home/izzy/prog/slick/Search/Graph.hs"
Giving: Error "GHC error: /home/izzy/prog/slick/Search/Graph.hs:514:50:\n    Not in scope: \8216numberOfHoles\8217\n"
Got: Load "/home/izzy/prog/slick/Search/Graph.hs"
These be the argHoles:fromList []
Giving: Error "GHC error: Mote.Holes.getHoleInfos: Non type-variable argument\n  in the constraint: MArray\n                       a (Map k_a7A60 (HashSet.HashSet [Move f_a7A61 o_a7A62])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray a (Map k0 (HashSet.HashSet [Move f0 o0])) f) =>\n        a i (Map k0 (HashSet.HashSet [Move f0 o0]))\n        -> i -> k0 -> f (HashSet.HashSet [Move f0 o0])\nIn an equation for \8216moveSequencesOfSizeAtMostMemoNotTooHoley'\8217:\n    moveSequencesOfSizeAtMostMemoNotTooHoley' branchOut n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          numberOfHoles = sum . map (numHoles . name . moveTrans)\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map k_a7A0g (HashSet.HashSet [a_a7A0h])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i, MArray a (Map k0 (HashSet.HashSet [a0])) f) =>\n        a i (Map k0 (HashSet.HashSet [a0]))\n        -> i -> k0 -> f (HashSet.HashSet [a0])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo'\8217:\n    moveSequencesOfSizeAtMostMemo' branchOut n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet [Move f o])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray a (Map (Word f o) (HashSet.HashSet [Move f o])) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet [Move f o]))\n        -> i -> Word f o -> f1 (HashSet.HashSet [Move f o])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo\8217:\n    moveSequencesOfSizeAtMostMemo tsList n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostMemo'\8217:\n    graphsOfSizeAtMostMemo' branchOut n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMost\8217:\n    graphsOfSizeAtMost tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i\n        -> Word f o\n        -> Trans f o\n        -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostH\8217:\n    graphsOfSizeAtMostH tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 fmap HashSet.unions . forM (branchOut ts start)\n                 $ \\ (b', move) -> ... }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go _ 0 b _\n            = return\n              $ if b == end then\n                    HashSet.singleton (idGraph end)\n                else\n                    HashSet.empty\n          go arr n b t\n            = do { memo <- readArray arr n;\n                   .... }"
Got: Load "/home/izzy/prog/slick/Scratch.hs"
These be the argHoles:fromList []
Giving: Error "GHC error: Mote.Holes.getHoleInfos: Illegal instance declaration for \8216MonadUnique (t m)\8217\n  (All instance types must be of the form (T a1 ... an)\n   where a1 ... an are *distinct type variables*,\n   and each type variable appears at most once in the instance head.\n   Use FlexibleInstances if you want to disable this.)\nIn the instance declaration for \8216MonadUnique (t m)\8217"
Got: Load "/home/izzy/prog/slick/Mote.hs"
These be the argHoles:fromList []
Giving: Ok
Got: Load "/home/izzy/prog/slick/Mote.hs"
These be the argHoles:fromList []
Giving: Ok
Got: Load "/home/izzy/prog/slick/Search/Graph.hs"
These be the argHoles:fromList []
Giving: Error "GHC error: Mote.Holes.getHoleInfos: Non type-variable argument\n  in the constraint: MArray\n                       a (Map k_a8m8n (HashSet.HashSet [a_a8m8o])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i, MArray a (Map k0 (HashSet.HashSet [a0])) f) =>\n        a i (Map k0 (HashSet.HashSet [a0]))\n        -> i -> k0 -> f (HashSet.HashSet [a0])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo'\8217:\n    moveSequencesOfSizeAtMostMemo' branchOut n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet [Move f o])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray a (Map (Word f o) (HashSet.HashSet [Move f o])) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet [Move f o]))\n        -> i -> Word f o -> f1 (HashSet.HashSet [Move f o])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo\8217:\n    moveSequencesOfSizeAtMostMemo tsList n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostMemo'\8217:\n    graphsOfSizeAtMostMemo' branchOut n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMost\8217:\n    graphsOfSizeAtMost tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i\n        -> Word f o\n        -> Trans f o\n        -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostH\8217:\n    graphsOfSizeAtMostH tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 fmap HashSet.unions . forM (branchOut ts start)\n                 $ \\ (b', move) -> ... }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go _ 0 b _\n            = return\n              $ if b == end then\n                    HashSet.singleton (idGraph end)\n                else\n                    HashSet.empty\n          go arr n b t\n            = do { memo <- readArray arr n;\n                   .... }"
Got: Load "/home/izzy/prog/slick/Search/Graph.hs"
These be the argHoles:fromList []
Giving: Error "GHC error: Mote.Holes.getHoleInfos: Non type-variable argument\n  in the constraint: MArray\n                       a (Map k_a8tQM (HashSet.HashSet ([Move f_a8tQN o_a8tQO], Int))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray a (Map k0 (HashSet.HashSet ([Move f0 o0], Int))) f) =>\n        a i (Map k0 (HashSet.HashSet ([Move f0 o0], Int)))\n        -> i -> k0 -> f (HashSet.HashSet ([Move f0 o0], Int))\nIn an equation for \8216moveSequencesOfSizeAtMostMemoNotTooHoley'\8217:\n    moveSequencesOfSizeAtMostMemoNotTooHoley' branchOut n start end\n      = map fst . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          numberOfHoles = snd\n          go arr n b\n            | b == end = return (HashSet.singleton ([], 0))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map k_a8tKZ (HashSet.HashSet [a_a8tL0])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i, MArray a (Map k0 (HashSet.HashSet [a0])) f) =>\n        a i (Map k0 (HashSet.HashSet [a0]))\n        -> i -> k0 -> f (HashSet.HashSet [a0])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo'\8217:\n    moveSequencesOfSizeAtMostMemo' branchOut n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet [Move f o])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray a (Map (Word f o) (HashSet.HashSet [Move f o])) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet [Move f o]))\n        -> i -> Word f o -> f1 (HashSet.HashSet [Move f o])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo\8217:\n    moveSequencesOfSizeAtMostMemo tsList n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostMemo'\8217:\n    graphsOfSizeAtMostMemo' branchOut n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMost\8217:\n    graphsOfSizeAtMost tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i\n        -> Word f o\n        -> Trans f o\n        -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostH\8217:\n    graphsOfSizeAtMostH tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 fmap HashSet.unions . forM (branchOut ts start)\n                 $ \\ (b', move) -> ... }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go _ 0 b _\n            = return\n              $ if b == end then\n                    HashSet.singleton (idGraph end)\n                else\n                    HashSet.empty\n          go arr n b t\n            = do { memo <- readArray arr n;\n                   .... }"
Got: SendStop
Giving: Stop
ec _ x _) . void) . replicateM _ . sequence\nfmap (fmap (\\x -> shows  x _) . enumFromTo _) . sequence_ . fmap (replicateM _)\nfmap (words . (\\x -> showList  x _) . fmap (\\x -> mkSrcLoc _ x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . null . (\\x -> readsPrec  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . exponent . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . null . (\\x -> splitAt  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . any _ . (\\x -> drop  x _)) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . (\\x -> PprProgramError  x _) . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (\\x -> AnnDocSection  x _) . enumFromTo _) . sequence\n(fmap . fmap) (rds_src . (\\x -> HsRules  x _) . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . isNegativeZero . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromThenTo  x _ _) . fromIntegral) . sequence\nfmap (fmap (\\x -> showsPrec  x _ _) . concat . splitAt _) . sequence\n(fmap . fmap) (unwords . fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . length . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . exponent . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . null . (\\x -> replicate  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showsPrec _ x _) . toInteger) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . ProgramError . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromThenTo  x _ _) . toEnum) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . null . divMod _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . replicateM_ _ . (\\x -> replicate  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . isInfinite . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . ProgramError . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . any _ . (\\x -> splitAt  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . isQuietHsExpr . (\\x -> HsBinTick  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . void . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . foldMap _ . (\\x -> splitAt  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . any _ . (\\x -> quotRem  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . enumFromThenTo _ _ . odd) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . AnnLineComment . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . enumFromThen _ . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . Panic . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . AnnDocOptions . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . foldMap _ . (\\x -> readsPrec  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . spans _ . quotRem _) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . length . enumFromThen _) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . (\\x -> PprPanic  x _) . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnDocCommentPrev . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . mkSrcLoc _ _ . fromEnum) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . sum . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . null . (\\x -> quotRem  x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . isIEEE . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . null . enumFromTo _) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . PprPanic _ . pp_rhs _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . all _ . (\\x -> splitAt  x _)) . sequence\n(fmap . fmap) (\\x -> showsPrec  x _ _) . sequence . concat . replicateM _\n(fmap . fmap) ((\\x -> showList  x _) . replicateM_ _ . enumFromTo _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (any _) . (\\x -> readsPrec  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromTo  x _) . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) (ml_hi_file . ModLocation _ _ . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . all _ . (\\x -> drop  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . enumFromThenTo _ _ . toInteger) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . ProgramError . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap toEnum . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . sum . (\\x -> quotRem  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . all _ . divMod _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . userError . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromThenTo _ x _) . toEnum) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromThenTo _ x _) . fromIntegral) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . length . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) (wd_src . (\\x -> Warnings  x _) . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap fromEnum . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) (rds_src . (\\x -> HsRules  x _) . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap fromIntegral . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . length . (\\x -> drop  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . length . (\\x -> replicate  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . null . (\\x -> quotRem  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showsPrec _ x _) . odd) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . docDeclDoc . (\\x -> DocGroup  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . length . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . fromEnum . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . floor . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> shows  x _) . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap Signal . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . AnnLineComment . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (\\x -> AnnDocSection  x _) . enumFromThen _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showsPrec _ x _) . fromIntegral) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . foldMap _ . enumFromThen _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> shows  x _) . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . UsageError . (\\x -> shows  x _)) . sequence\n(fmap . fmap) (unlines . fmap (\\x -> showsPrec  x _ _) . enumFromThen _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . enumFromThenTo _ _ . fromIntegral) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . length . quotRem _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showsPrec _ x _) . toEnum) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . length . enumFromTo _) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . null . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . PprSorry _ . pp_rhs _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . concat . span _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromThen  x _) . (\\x -> scaleFloat  x _)) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . concat) . replicateM _ . sequence\n(fmap . fmap) ((\\x -> showList  x _) . replicateM_ _ . enumFromThen _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnDocOptions . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . length . (\\x -> readsPrec  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap fromIntegral . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . foldMap _ . quotRem _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . join) . replicateM _ . sequence\n(fmap . fmap) ((\\x -> showList  x _) . enumFromThenTo _ _ . toEnum) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . enumFromThenTo _ _ . fromEnum) . sequence\n(fmap . fmap) (unlines . fmap (\\x -> showsPrec _ x _) . enumFromThen _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . isDenormalized . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . AnnDocCommentPrev . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . null . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . any _ . (\\x -> replicate  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . all _ . enumFromTo _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (\\x -> scaleFloat  x _) . enumFromThen _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (all _) . (\\x -> readsPrec  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . null . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . sum . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . length . (\\x -> take  x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . null . quotRem _) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . isDenormalized . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . round . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap odd . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . InstallationError . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) (unwords . fmap (\\x -> shows  x _) . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . all _ . (\\x -> readsPrec  x _)) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . CmdLineError . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . null . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . (\\x -> mkSrcLoc _ x _) . fromEnum) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . sum . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . (\\x -> scaleFloat  x _) . fromEnum) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromThenTo  x _ _) . even) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromThen  x _) . encodeFloat _) . sequence\n(fmap . fmap) (\\x -> showsPrec  x _ _) . sequence . concat . splitAt _\n(fmap . fmap) ((\\x -> showsPrec _ x _) . read . (\\x -> shows  x _)) . sequence\n(fmap . fmap) (unwords . fmap (\\x -> showsPrec  x _ _) . enumFromThen _) . sequence\nfmap (fmap (\\x -> showsPrec  x _ _) . concat) . replicateM _ . sequence\nfmap (fmap (\\x -> showsPrec  x _ _) . concat . span _) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . null . (\\x -> drop  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . Sorry . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap toInteger . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . Sorry . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . all _ . (\\x -> quotRem  x _)) . sequence\n(fmap . fmap) (unlines . fmap (\\x -> showsPrec  x _ _) . enumFromTo _) . sequence\n(fmap . fmap) (unwords . fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . isInfinite . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . void . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . AnnBlockComment . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnBlockComment . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . any _ . enumFromTo _) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . sum . divMod _) . sequence\nfmap (fmap (\\x -> showsPrec  x _ _) . join) . replicateM _ . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . isNaN . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . sum . enumFromThen _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . length . (\\x -> drop  x _)) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . PprProgramError _ . pp_rhs _) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . InstallationError . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . fromEnum . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . CmdLineError . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . null . (\\x -> take  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . any _ . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) (unlines . fmap (\\x -> showsPrec  x _ _) . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . sum . (\\x -> quotRem  x _)) . sequence\n(fmap . fmap) (unlines . fmap (\\x -> shows  x _) . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromThenTo _ x _) . fromEnum) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . isInfinite . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap even . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (\\x -> scaleFloat  x _) . enumFromTo _) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . (\\x -> PhaseFailed  x _) . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showList  x _) . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . length . (\\x -> replicate  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . InstallationError . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . isDenormalized . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . isNegativeZero . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . AnnBlockComment . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) (\\x -> showsPrec _ x _) . sequence . concat . replicateM _\n(fmap . fmap) ((\\x -> showsPrec _ x _) . length . quotRem _) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . length . (\\x -> readsPrec  x _)) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . PprSorry _ . pp_rhs _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . truncate . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . (\\x -> encodeFloat  x _) . toInteger) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . length . enumFromTo _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showsPrec _ x _) . Signal) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap fromEnum . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . AnnDocCommentNext . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap odd . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . fromEnum . encodeFloat _) . sequence\n(fmap . fmap) (unwords . fmap (\\x -> showsPrec  x _ _) . enumFromTo _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . any _ . divMod _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . Panic . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . enumFromThenTo _ _ . even) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap toEnum . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . any _ . enumFromThen _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . length . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) (unlines . fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap Signal . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . sum . quotRem _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showsPrec  x _ _) . fromEnum) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . length . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) (unlines . fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . ProgramError . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . isIEEE . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . length . (\\x -> quotRem  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . hsExprNeedsParens . (\\x -> HsBinTick  x _ _)) . sequence\n(fmap . fmap) (\\x -> showsPrec _ x _) . sequence . concat . splitAt _\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showList  x _) . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . foldMap _ . (\\x -> drop  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . CmdLineError . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . null . enumFromTo _) . sequence\n(fmap . fmap) (wd_src . (\\x -> Warnings  x _) . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) (unwords . fmap (\\x -> showsPrec  x _ _) . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . userError . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . foldMap _ . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (encodeFloat _) . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . any _ . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . read . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . exponent . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . AnnDocCommentPrev . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . isInfinite . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . encodeFloat _ . fromEnum) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnDocCommentNamed . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromThenTo _ x _) . odd) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . sum . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . isIEEE . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . length . enumFromThen _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . isAtomicHsExpr . (\\x -> HsBinTick  x _ _)) . sequence\n(fmap . fmap) (unlines . fmap (\\x -> showsPrec _ x _) . enumFromTo _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . (\\x -> PprPanic  x _) . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . sum . quotRem _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . any _ . (\\x -> readsPrec  x _)) . sequence\n(fmap . fmap) (unwords . fmap (\\x -> showsPrec _ x _) . enumFromThen _) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . null . (\\x -> splitAt  x _)) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . Panic . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . AnnDocCommentNext . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showList  x _) . enumFromTo _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . floatDigits . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . PprPanic _ . pp_rhs _) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . null . (\\x -> replicate  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . null . divMod _) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . fromEnum . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showsPrec _ x _) . fromEnum) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (\\x -> AnnDocSection  x _) . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . srcLocSpan . mkSrcLoc _ _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap fromIntegral . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . sum . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . (\\x -> PprProgramError  x _) . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . enumFromTo _ . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . CmdLineError . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromThenTo  x _ _) . fromEnum) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap toInteger . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . foldMap _ . (\\x -> take  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . all _ . enumFromThen _) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . floatDigits . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap fromEnum . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . floatRadix . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap toEnum . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . length . (\\x -> splitAt  x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . isIEEE . encodeFloat _) . sequence\n(fmap . fmap) (unlines . fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (encodeFloat _) . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . replicateM_ _ . (\\x -> take  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap Signal . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnDocOptionsOld . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . ProgramError . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . length . (\\x -> quotRem  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . foldMap _ . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . null . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . all _ . (\\x -> take  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . read . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . any _ . quotRem _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . AnnDocOptions . (\\x -> showsPrec _ x _)) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . join) . sequence . fmap (replicateM _)\n(fmap . fmap) ((\\x -> showList  x _) . fmap even . enumFromThenTo _ _) . sequence\n(fmap . fmap) (\\x -> showsPrec _ x _) . sequence . join . replicateM _\n(fmap . fmap) ((\\x -> showsPrec _ x _) . length . divMod _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . enumFromTo _ . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . sum . enumFromThen _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . floatRadix . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . Sorry . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . sum . divMod _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . isNaN . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . Panic . (\\x -> showsPrec _ x _)) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . concat) . sequence . fmap (replicateM _)\n(fmap . fmap) (\\x -> showsPrec _ x _) . sequence . concat . span _\n(fmap . fmap) ((\\x -> showGhcException  x _) . (\\x -> PprSorry  x _) . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . AnnDocCommentNamed . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) (ml_obj_file . ModLocation _ _ . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . UsageError . (\\x -> showsPrec  x _ _)) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . join . replicateM _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . concat . replicateM _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . srcLocSpan . (\\x -> mkSrcLoc _ x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromThenTo  x _ _) . toInteger) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . sum . enumFromTo _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . AnnDocOptionsOld . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnLineComment . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . enumFromThen _ . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . isQuietHsExpr . (\\x -> HsBinTick _ x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . replicateM_ _ . (\\x -> drop  x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . isNaN . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) (unlines . fmap (\\x -> showsPrec  x _ _) . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . (\\x -> AnnDocSection  x _) . fromEnum) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . userError . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . hsExprNeedsParens . (\\x -> HsBinTick _ x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . foldMap _ . (\\x -> quotRem  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . replicateM_ _ . (\\x -> enumFromTo  x _)) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . concat . splitAt _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . null . (\\x -> drop  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . length . (\\x -> take  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . InstallationError . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . sum . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . isNaN . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . InstallationError . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . PprProgramError _ . pp_rhs _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . (\\x -> PhaseFailed  x _) . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . foldMap _ . (\\x -> replicate  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . length . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . AnnDocCommentNamed . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (\\x -> scaleFloat  x _) . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . AnnDocSection _ . (\\x -> shows  x _)) . sequence\n(fmap . fmap) (\\x -> showsPrec  x _ _) . sequence . join . replicateM _\n(fmap . fmap) ((\\x -> shows  x _) . isAtomicHsExpr . (\\x -> HsBinTick _ x _)) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . UsageError . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) (\\x -> showsPrec  x _ _) . sequence . concat . span _\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromThenTo  x _ _) . odd) . sequence\nfmap (fmap (\\x -> showsPrec  x _ _) . concat) . sequence . fmap (replicateM _)\n(fmap . fmap) (unwords . fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . null . (\\x -> enumFromTo  x _)) . sequence\nfmap (fmap (\\x -> showsPrec  x _ _) . concat . replicateM _) . sequence\nfmap (fmap (\\x -> showsPrec  x _ _) . join . replicateM _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . floor . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . all _ . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . null . quotRem _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . Sorry . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . sum . enumFromTo _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap toInteger . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . null . (\\x -> readsPrec  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . spans _ . divMod _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showParen  x _ _) . odd) . sequence\nfmap (fmap (\\x -> showsPrec  x _ _) . join) . sequence . fmap (replicateM _)\n(fmap . fmap) ((\\x -> showList  x _) . fmap (foldMap _) . (\\x -> readsPrec  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . void . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . foldMap _ . enumFromTo _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . replicateM_ _ . (\\x -> readsPrec  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnDocCommentNext . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . all _ . (\\x -> replicate  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (encodeFloat _) . enumFromTo _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . UsageError . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . length . (\\x -> splitAt  x _)) . sequence\nfmap (fmap (\\x -> showsPrec  x _ _) . concat . break _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . isNegativeZero . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . CmdLineError . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . isDenormalized . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . null . enumFromThen _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromTo  x _) . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap even . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . AnnDocOptionsOld . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . sum . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . any _ . (\\x -> take  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . null . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showParen  x _ _) . even) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . spans _ . (\\x -> quotRem  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . truncate . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) (unwords . fmap (\\x -> showsPrec  x _ _) . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . floatDigits . encodeFloat _) . sequence\n(fmap . fmap) (ml_hi_file . (\\x -> ModLocation _ x _) . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . replicateM_ _ . (\\x -> enumFromThen  x _)) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . concat . break _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromThenTo _ x _) . even) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . all _ . quotRem _) . sequence\n(fmap . fmap) (\\x -> showsPrec  x _ _) . sequence . concat . break _\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showList  x _) . (\\x -> shows  x _)) . sequence\n(fmap . fmap) (unwords . fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) (\\x -> showsPrec _ x _) . sequence . concat . break _\n(fmap . fmap) (ml_obj_file . (\\x -> ModLocation _ x _) . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (\\x -> scaleFloat  x _) . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . null . (\\x -> take  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . length . divMod _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . UsageError . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . Sorry . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showsPrec _ x _) . even) . sequence\n(fmap . fmap) (unwords . fmap (\\x -> showsPrec _ x _) . enumFromTo _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> shows  x _) . (\\x -> AnnDocSection  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromThenTo _ x _) . toInteger) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . isNegativeZero . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . exponent . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . length . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (encodeFloat _) . enumFromThen _) . sequence\n(fmap . fmap) (unlines . fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (\\x -> AnnDocSection  x _) . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . (\\x -> PprSorry  x _) . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . foldMap _ . divMod _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . round . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . Panic . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap odd . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . null . enumFromThen _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . all _ . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . floatDigits . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showList  x _) . enumFromThen _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _)) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _)) . sequence_\n(fmap . fmap) ((\\x -> showsPrec _ x _) . mkSrcLoc _ _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . (\\x -> mkSrcLoc _ x _)) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . replicateM_ _ . (\\x -> enumFromThen  x _)) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _)) . void . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThen _ . all _) . sequence\nfmap (fmap (\\x -> showsPrec  x _ _) . join . fmap (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) (\\x -> showsPrec _ x _) . replicateM _ . print . any _\nfmap (words . (\\x -> showsPrec _ x _)) . setBreakOff _ _ . length\nfmap (fmap ((\\x -> showList  x _) . enumFromTo _) . enumFromThenTo _ _) . sequence_\nfmap (fmap ((\\x -> showList  x _) . (\\x -> enumFromThenTo _ x _)) . (\\x -> enumFromThen  x _)) . sequence_\nfmap (fmap (\\x -> showsPrec  x _ _) . (\\x -> enumFromThenTo _ x _) . fromEnum) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThen  x _)) . sequence_ . fmap (replicateM_ _)\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromTo  x _) . any _) . sequence\n(fmap . fmap) (\\x -> showsPrec _ x _) . replicateM _ . sequence_ . fmap (replicateM _)\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo  x _ _)) . replicateM_ _ . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThen  x _)) . print . all _\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _)) . print . null\nfmap (fmap (\\x -> showsPrec _ x _) . void . zip3 _ _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromTo _) . replicateM_ _ . sequence\nfmap (fmap (\\x -> showsPrec  x _ _) . join . fmap (enumFromThenTo _ _)) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThen  x _)) . print . foldMap _\nfmap (words . (\\x -> showParen  x _ _)) . setBreakOn _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThen _) . print . all _\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThen  x _)) . setBreakOff _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThen _) . sequence_ . fmap (replicateM_ _)\n(fmap . fmap) (\\x -> showsPrec _ x _) . replicateM _ . print . all _\nfmap (fmap (\\x -> showsPrec _ x _) . replicateM_ _ . zip _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . replicateM_ _) . sequence . fmap (replicateM_ _)\nfmap (fmap (\\x -> showsPrec _ x _) . replicateM_ _) . replicateM _ . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _)) . sequence_ . fmap void\n(fmap . fmap) (\\x -> showsPrec _ x _) . sequence . fmap join . (fmap . fmap) (setBreakOn _ _)\nfmap (fmap ((\\x -> showList  x _) . (\\x -> enumFromTo  x _)) . enumFromThenTo _ _) . sequence_\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromThenTo  x _ _)) . replicateM _ . sequence_\nreplicateM _ . readFile . (\\x -> showParen  x _ _) . all _\nfmap (fmap (\\x -> showParen  x _ _) . enumFromTo _ . all _) . sequence\nfmap (fmap ((\\x -> showsPrec  x _ _) . fromEnum) . (\\x -> enumFromThenTo _ x _)) . sequence_\nfmap (fmap (\\x -> showParen  x _ _) . enumFromThenTo _ _ . null) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromTo  x _) . all _) . sequence\n(fmap . fmap) (\\x -> showsPrec _ x _) . sequence . fmap (replicateM_ _) . fmap (replicateM_ _)\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo  x _ _) . any _) . sequence\n(fmap . fmap) (\\x -> showsPrec _ x _) . replicateM _ . sequence_ . fmap (replicateM_ _)\nfmap (fmap (\\x -> showsPrec _ x _) . void . (\\x -> enumFromThenTo  x _ _)) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromTo _ . all _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . enumFromThenTo _ _) . sequence . fmap (replicateM_ _)\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _)) . print . null\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _)) . sequence_ . PrefixPatSyn\nfmap (fmap ((\\x -> showList  x _) . enumFromThenTo _ _) . replicateM_ _) . sequence\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo _ x _)) . sequence_ . fmap (replicateM _)\n(fmap . fmap) (\\x -> showParen  x _ _) . sequence . fmap join . (fmap . fmap) (setBreakOn _ _)\n(fmap . fmap) (\\x -> showsPrec _ x _) . replicateM _ . replicateM_ _ . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _)) . void . sequence\nfmap (fmap ((\\x -> showList  x _) . enumFromThen _) . enumFromThenTo _ _) . sequence_\nfmap (lines . (\\x -> showsPrec _ x _)) . setBreakOn _ _ . length\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo _ x _)) . print . any _\nfmap (fmap (\\x -> showsPrec  x _ _) . (\\x -> enumFromThenTo  x _ _) . sum) . sequence\nfmap (fmap ((\\x -> showList  x _) . (\\x -> enumFromThenTo _ x _)) . (\\x -> enumFromTo  x _)) . sequence_\nfmap (fmap (\\x -> showList  x _) . replicateM _ . enumFromThenTo _ _) . sequence_\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showsPrec _ x _)) . sequence . fmap (replicateM_ _)\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _) . length) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _ . null) . sequence\nfmap (fmap ((\\x -> showList  x _) . enumFromThenTo _ _) . enumFromThen _) . sequence_\nfmap (fmap (\\x -> showsPrec  x _ _) . concat . fmap (\\x -> enumFromThenTo _ x _)) . sequence\nfmap (fmap ((\\x -> showList  x _) . (\\x -> enumFromThenTo  x _ _)) . (\\x -> enumFromTo  x _)) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . join . fmap (\\x -> enumFromThenTo  x _ _)) . sequence\nfmap (fmap ((\\x -> showList  x _) . (\\x -> enumFromThen  x _)) . enumFromThenTo _ _) . sequence_\nfmap (fmap (\\x -> showsPrec  x _ _) . enumFromThenTo _ _ . length) . sequence\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromTo  x _)) . setBreakOn _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . replicateM_ _ . userHsTyVarBndrs _) . sequence\nfmap (fmap (\\x -> shows  x _) . replicateM_ _ . (\\x -> enumFromThenTo  x _ _)) . sequence_\nfmap (fmap ((\\x -> showList  x _) . enumFromThenTo _ _) . (\\x -> enumFromTo  x _)) . sequence_\nfmap (fmap ((\\x -> showsPrec _ x _) . foldMap _) . replicateM _) . sequence\nreplicateM _ . readFile . (\\x -> showsPrec _ x _) . foldMap _\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromTo  x _)) . print . foldMap _\nfmap (fmap (\\x -> shows  x _) . enumFromThenTo _ _) . print . foldMap _\n(fmap . fmap) ((\\x -> showsPrec _ x _) . foldMap _) . sequence . fmap (replicateM _)\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _) . print . null\nfmap (fmap ((\\x -> showList  x _) . enumFromThen _) . (\\x -> enumFromThenTo  x _ _)) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _) . void . sequence\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo _ x _)) . replicateM_ _ . sequence\nfmap (fmap (\\x -> showsPrec  x _ _) . concat . fmap (\\x -> enumFromThenTo  x _ _)) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromTo  x _)) . replicateM_ _ . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _) . void . sequence_\nfmap (words . (\\x -> showsPrec _ x _)) . setBreakOn _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _)) . print . length\nfmap (fmap (\\x -> showParen  x _ _) . enumFromTo _ . any _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _) . length) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . replicateM_ _) . replicateM _ . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . join . fmap (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . any _) . replicateM _ . sequence\nfmap (fmap ((\\x -> showList  x _) . enumFromThenTo _ _) . enumFromTo _) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThen _) . print . any _\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThen _) . sequence_ . fmap (replicateM _)\nfmap (fmap (\\x -> showsPrec  x _ _) . enumFromThenTo _ _ . sum) . sequence\nfmap (fmap ((\\x -> showsPrec _ x _) . any _) . replicateM _) . sequence\nfmap (fmap ((\\x -> showsPrec _ x _) . fromEnum) . (\\x -> enumFromThenTo  x _ _)) . sequence_\n(fmap . fmap) ((\\x -> showParen  x _ _) . all _) . replicateM _ . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . replicateM_ _ . replicateM_ _) . sequence\nfmap (fmap ((\\x -> showsPrec  x _ _) . fromEnum) . (\\x -> enumFromThenTo  x _ _)) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _)) . void . sequence_\n(fmap . fmap) ((\\x -> showsPrec _ x _) . any _) . sequence . fmap (replicateM _)\nfmap (fmap ((\\x -> showList  x _) . (\\x -> enumFromThenTo _ x _)) . enumFromTo _) . sequence_\nfmap (fmap ((\\x -> showsPrec _ x _) . all _) . userHsTyVarBndrs _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _)) . void . sequence_\nfmap (fmap (\\x -> shows  x _) . enumFromThenTo _ _ . all _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . replicateM_ _ . enumFromThen _) . sequence_\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo _ x _)) . sequence_ . fmap (replicateM_ _)\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo _ x _)) . print . all _\nfmap (fmap (\\x -> showsPrec  x _ _) . concat . fmap (enumFromThenTo _ _)) . sequence\n(fmap . fmap) (\\x -> shows  x _) . replicateM _ . setBreakOff _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _) . sum) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . enumFromThenTo _ _) . replicateM _ . sequence_\n(fmap . fmap) ((\\x -> showList  x _) . fmap (\\x -> mkSrcLoc _ x _)) . replicateM _ . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _)) . print . length\nfmap (fmap (\\x -> showsPrec  x _ _) . join . fmap (\\x -> enumFromThenTo _ x _)) . sequence\nfmap (fmap (\\x -> shows  x _) . enumFromThen _) . setBreakOn _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThen _) . print . foldMap _\nfmap (fmap (\\x -> showsPrec _ x _) . replicateM_ _ . (\\x -> enumFromTo  x _)) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . sequence_ . fmap (\\x -> enumFromThenTo  x _ _)) . sequence\nfmap (fmap ((\\x -> showList  x _) . (\\x -> enumFromTo  x _)) . (\\x -> enumFromThenTo _ x _)) . sequence_\nfmap (fmap (\\x -> shows  x _) . replicateM_ _ . enumFromThenTo _ _) . sequence_\n(fmap . fmap) ((\\x -> showsPrec _ x _) . all _) . replicateM _ . sequence\nfmap (fmap (\\x -> showParen  x _ _) . enumFromThen _ . any _) . sequence\nfmap (fmap (\\x -> showsPrec  x _ _) . (\\x -> enumFromThenTo  x _ _) . fromEnum) . sequence_\nreplicateM _ . readFile . (\\x -> showsPrec _ x _) . all _\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromTo _) . print . all _\nfmap (fmap (\\x -> showList  x _) . replicateM _ . (\\x -> enumFromThenTo  x _ _)) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThen _ . any _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _ . length) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromThenTo _ x _)) . replicateM _ . sequence_\nfmap (fmap ((\\x -> showParen  x _ _) . any _) . zip _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromTo _) . sequence_ . fmap (replicateM_ _)\n(fmap . fmap) ((\\x -> showList  x _) . fmap (mkSrcLoc _ _)) . replicateM _ . sequence\nfmap (fmap ((\\x -> showList  x _) . enumFromThen _) . (\\x -> enumFromThenTo _ x _)) . sequence_\nfmap (fmap ((\\x -> showsPrec _ x _) . any _) . zip _) . sequence\nfmap (fmap (\\x -> shows  x _) . enumFromTo _) . setBreakOff _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _)) . sequence_ . PrefixPatSyn\nfmap (fmap (\\x -> shows  x _) . enumFromThenTo _ _) . replicateM_ _ . sequence_\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo  x _ _)) . print . foldMap _\nfmap (fmap (\\x -> showsPrec _ x _) . concat . fmap (\\x -> enumFromThenTo _ x _)) . sequence\nfmap (fmap (\\x -> showParen  x _ _) . (\\x -> enumFromTo  x _) . all _) . sequence\nfmap (fmap ((\\x -> showList  x _) . (\\x -> enumFromThen  x _)) . (\\x -> enumFromThenTo  x _ _)) . sequence_\nfmap (fmap ((\\x -> showsPrec _ x _) . fromEnum) . enumFromThenTo _ _) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromTo _) . print . foldMap _\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _) . sequence_ . fmap void\nfmap (fmap (\\x -> showsPrec  x _ _) . (\\x -> enumFromThenTo _ x _) . length) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . sequence_ . fmap (enumFromThenTo _ _)) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _)) . sequence_ . fmap void\nfmap (fmap ((\\x -> showList  x _) . enumFromTo _) . (\\x -> enumFromThenTo _ x _)) . sequence_\nfmap (fmap ((\\x -> showList  x _) . enumFromThenTo _ _) . (\\x -> enumFromThen  x _)) . sequence_\nfmap (fmap (\\x -> showParen  x _ _) . (\\x -> enumFromThen  x _) . any _) . sequence\nfmap (fmap (\\x -> shows  x _) . enumFromThenTo _ _) . print . any _\nfmap (fmap (\\x -> showsPrec _ x _) . maybeToList) . getBreak _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThen  x _)) . replicateM_ _ . sequence\nfmap (fmap (\\x -> shows  x _) . enumFromThenTo _ _) . sequence_ . fmap (replicateM _)\nfmap (fmap (\\x -> showsPrec _ x _) . concat . fmap (enumFromThenTo _ _)) . sequence\nreplicateM _ . readFile . (\\x -> showsPrec _ x _) . any _\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _) . sequence_ . PrefixPatSyn\nfmap (fmap ((\\x -> showParen  x _ _) . any _) . userHsTyVarBndrs _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromTo _) . replicateM_ _ . sequence_\nfmap (fmap ((\\x -> showsPrec _ x _) . fromEnum) . (\\x -> enumFromThenTo _ x _)) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThen  x _) . any _) . sequence\nfmap (fmap (\\x -> showParen  x _ _) . (\\x -> enumFromThenTo _ x _) . null) . sequence\nfmap (fmap ((\\x -> showList  x _) . (\\x -> enumFromTo  x _)) . (\\x -> enumFromThenTo  x _ _)) . sequence_\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo  x _ _)) . sequence_ . fmap (replicateM _)\nfmap (fmap ((\\x -> showsPrec  x _ _) . fromEnum) . enumFromThenTo _ _) . sequence_\n(fmap . fmap) (\\x -> showsPrec _ x _) . replicateM _ . print . foldMap _\nfmap (fmap (\\x -> shows  x _) . replicateM_ _ . zip3 _ _) . sequence\nfmap (fmap (\\x -> showsPrec  x _ _) . (\\x -> enumFromThenTo _ x _) . sum) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThen  x _)) . replicateM_ _ . sequence_\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo  x _ _)) . print . any _\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _) . sequence_ . listToMaybe\nfmap (fmap (\\x -> shows  x _) . enumFromThen _) . setBreakOff _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _) . fromEnum) . sequence_\n(fmap . fmap) (\\x -> shows  x _) . replicateM _ . setBreakOn _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromTo  x _)) . replicateM_ _ . sequence\nfmap (fmap (\\x -> showsPrec  x _ _) . enumFromThenTo _ _ . fromEnum) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _) . null) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _)) . sequence_ . listToMaybe\nfmap (lines . (\\x -> showParen  x _ _)) . setBreakOff _ _ . length\nfmap (fmap ((\\x -> showList  x _) . (\\x -> enumFromThenTo _ x _)) . replicateM_ _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _ . sum) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThen  x _)) . print . any _\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo _ x _) . any _) . sequence\nfmap (fmap ((\\x -> showList  x _) . (\\x -> enumFromThenTo _ x _)) . enumFromThen _) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . replicateM_ _ . enumFromTo _) . sequence_\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo _ x _)) . replicateM_ _ . sequence_\n(fmap . fmap) ((\\x -> showsPrec _ x _) . foldMap _) . replicateM _ . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThen  x _)) . sequence_ . fmap (replicateM _)\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromThenTo _ x _)) . sequence . fmap (replicateM_ _)\nfmap (fmap (\\x -> shows  x _) . enumFromThenTo _ _) . replicateM_ _ . sequence\nfmap (fmap (\\x -> showList  x _) . replicateM _ . (\\x -> enumFromThenTo _ x _)) . sequence_\nfmap (fmap ((\\x -> showList  x _) . (\\x -> enumFromThenTo  x _ _)) . enumFromTo _) . sequence_\nfmap (fmap (\\x -> shows  x _) . enumFromTo _) . setBreakOn _ _ . length\nfmap (fmap ((\\x -> showList  x _) . (\\x -> enumFromThen  x _)) . (\\x -> enumFromThenTo _ x _)) . sequence_\nfmap (fmap ((\\x -> showParen  x _ _) . all _) . userHsTyVarBndrs _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . replicateM_ _ . replicateM _) . sequence\n(fmap . fmap) (\\x -> showsPrec _ x _) . sequence . fmap (replicateM_ _) . fmap (replicateM _)\n(fmap . fmap) ((\\x -> showParen  x _ _) . any _) . sequence . fmap (replicateM _)\nreplicateM _ . readFile . (\\x -> showParen  x _ _) . any _\nfmap (fmap ((\\x -> showsPrec _ x _) . foldMap _) . userHsTyVarBndrs _) . sequence\nfmap (fmap ((\\x -> showList  x _) . (\\x -> enumFromThenTo  x _ _)) . (\\x -> enumFromThen  x _)) . sequence_\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo _ x _)) . print . foldMap _\nfmap (fmap (\\x -> shows  x _) . enumFromThenTo _ _ . any _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . replicateM_ _) . sequence . fmap (replicateM _)\nfmap (fmap (\\x -> showsPrec _ x _) . sequence_ . fmap (\\x -> enumFromThenTo _ x _)) . sequence\nfmap (fmap ((\\x -> showParen  x _ _) . any _) . replicateM _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . void . enumFromThenTo _ _) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _) . fromEnum) . sequence_\n(fmap . fmap) (\\x -> showsPrec _ x _) . sequence . fmap join . (fmap . fmap) (setBreakOff _ _)\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThen  x _)) . setBreakOn _ _ . length\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo  x _ _)) . replicateM_ _ . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromTo  x _)) . print . any _\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromTo  x _)) . sequence_ . fmap (replicateM _)\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromTo _ . any _) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . all _) . sequence . fmap (replicateM _)\nfmap (fmap ((\\x -> showList  x _) . (\\x -> enumFromThenTo  x _ _)) . replicateM_ _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . join . fmap (enumFromThenTo _ _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromThenTo  x _ _)) . sequence . fmap (replicateM_ _)\nfmap (words . (\\x -> showParen  x _ _)) . setBreakOff _ _ . length\n(fmap . fmap) ((\\x -> showsPrec _ x _) . any _) . replicateM _ . sequence\nfmap (fmap ((\\x -> showParen  x _ _) . all _) . replicateM _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . void . (\\x -> enumFromThenTo _ x _)) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _) . print . length\nfmap (fmap ((\\x -> showList  x _) . enumFromTo _) . (\\x -> enumFromThenTo  x _ _)) . sequence_\nfmap (fmap ((\\x -> showList  x _) . (\\x -> enumFromThenTo  x _ _)) . enumFromThen _) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromTo  x _)) . sequence_ . fmap (replicateM_ _)\nfmap (fmap ((\\x -> showsPrec _ x _) . any _) . userHsTyVarBndrs _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromTo _) . sequence_ . fmap (replicateM _)\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo  x _ _) . all _) . sequence\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo _ x _) . all _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (\\x -> mkSrcLoc _ x _)) . sequence . fmap (replicateM _)\nfmap (fmap (\\x -> showParen  x _ _) . (\\x -> enumFromThen  x _) . all _) . sequence\nfmap (fmap ((\\x -> showList  x _) . fmap (\\x -> mkSrcLoc _ x _)) . replicateM _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _) . sum) . sequence\n(fmap . fmap) (\\x -> showParen  x _ _) . sequence . fmap join . (fmap . fmap) (setBreakOff _ _)\nfmap (fmap (\\x -> showsPrec  x _ _) . (\\x -> enumFromThenTo  x _ _) . length) . sequence\nfmap (lines . (\\x -> showsPrec _ x _)) . setBreakOff _ _ . length\nfmap (fmap (\\x -> shows  x _) . enumFromThenTo _ _) . sequence_ . fmap (replicateM_ _)\nfmap (fmap (\\x -> shows  x _) . enumFromThenTo _ _) . print . all _\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showsPrec _ x _)) . replicateM _ . sequence_\nfmap (fmap ((\\x -> showsPrec _ x _) . foldMap _) . zip _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . concat . fmap (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . all _) . sequence . fmap (replicateM _)\nfmap (fmap (\\x -> showParen  x _ _) . (\\x -> enumFromThenTo  x _ _) . null) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromTo _) . print . any _\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThen _) . replicateM_ _ . sequence\nfmap (fmap ((\\x -> showsPrec _ x _) . all _) . replicateM _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromTo  x _)) . print . all _\nfmap (fmap ((\\x -> showParen  x _ _) . all _) . zip _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _ . fromEnum) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _) . null) . sequence\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo  x _ _)) . print . all _\nfmap (fmap ((\\x -> showsPrec _ x _) . all _) . zip _) . sequence\n(fmap . fmap) (\\x -> showsPrec _ x _) . replicateM _ . replicateM_ _ . sequence_\nfmap (fmap (\\x -> shows  x _) . replicateM_ _ . (\\x -> enumFromThenTo _ x _)) . sequence_\n(fmap . fmap) ((\\x -> showList  x _) . fmap (mkSrcLoc _ _)) . sequence . fmap (replicateM _)\nfmap (fmap (\\x -> showParen  x _ _) . enumFromThen _ . all _) . sequence\nfmap (fmap ((\\x -> showList  x _) . fmap (mkSrcLoc _ _)) . replicateM _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThen  x _) . all _) . sequence\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromTo  x _)) . setBreakOff _ _ . length\nfmap (fmap (\\x -> showParen  x _ _) . (\\x -> enumFromTo  x _) . any _) . sequence\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo  x _ _)) . sequence_ . fmap (replicateM_ _)\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThen _) . replicateM_ _ . sequence_\nfmap (lines . (\\x -> showParen  x _ _)) . setBreakOn _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _)) . sequence_ . listToMaybe\n(fmap . fmap) ((\\x -> showParen  x _ _) . all _ . divMod _) . sequence\n(fmap . fmap) (ml_hi_file . ModLocation _ _ . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (\\x -> mkSrcLoc _ x _) . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . enumFromThenTo _ _ . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . sum . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . read . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . sum . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . replicateM_ _ . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (\\x -> scaleFloat  x _) . enumFromThenTo _ _) . sequence\n(fmap . fmap) (ml_obj_file . ModLocation _ _ . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . userError . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . (\\x -> PhaseFailed  x _) . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . all _ . enumFromThen _) . sequence\n(fmap . fmap) (ml_hi_file . (\\x -> ModLocation _ x _) . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . any _ . quotRem _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . (\\x -> ModLocation _ x _) . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . hsExprNeedsParens . (\\x -> HsBinTick  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . CmdLineError . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . null . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) (unlines . fmap (\\x -> showsPrec  x _ _) . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) (unwords . fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . null . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . hsExprNeedsParens . (\\x -> HsBinTick  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . Panic . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . all _ . (\\x -> drop  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . all _ . (\\x -> splitAt  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnDocOptions . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showsPrec _ x _) . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . foldMap _ . (\\x -> readsPrec  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . ModLocation _ _ . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . any _ . quotRem _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . mkSrcSpan _ . mkSrcLoc _ _) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . all _ . enumFromTo _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . spans _ . quotRem _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . PprProgramError _ . (\\x -> pprTransStmt _ x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . null . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . any _ . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnLineComment . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . all _ . enumFromTo _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . foldMap _ . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (\\x -> scaleFloat  x _) . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (\\x -> AnnDocSection  x _) . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . foldMap _ . (\\x -> drop  x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . isAtomicHsExpr . (\\x -> HsBinTick  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . all _ . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . all _ . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . PprPanic _ . (\\x -> pprTransStmt _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . null . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . (\\x -> PprPanic  x _) . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (encodeFloat _) . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnDocOptions . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . all _ . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . PprSorry _ . pp_rhs _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnDocCommentNamed . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . all _ . (\\x -> take  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (mkSrcLoc _ _) . enumFromThen _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showList  x _) . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) (unlines . fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . AnnDocSection _ . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) (unwords . fmap (\\x -> showsPrec  x _ _) . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . length . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . (\\x -> PprPanic  x _) . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . all _ . quotRem _) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . length . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . length . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . any _ . (\\x -> replicate  x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . any _ . divMod _) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . PprSorry _ . (\\x -> pprTransStmt _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . foldMap _ . (\\x -> quotRem  x _)) . sequence\n(fmap . fmap) (unwords . fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showList  x _) . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . (\\x -> mkSrcLoc _ x _) . fromEnum) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . any _ . enumFromThen _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (mkSrcLoc _ _) . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . PprSorry _ . (\\x -> pprTransStmt _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . any _ . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . (\\x -> PprPanic  x _) . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . any _ . (\\x -> quotRem  x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . any _ . (\\x -> replicate  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . length . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . foldMap _ . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . mkSrcLoc _ _ . fromEnum) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . spans _ . divMod _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (\\x -> AnnDocSection  x _) . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . UsageError . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnDocSection _ . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . all _ . (\\x -> replicate  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showsPrec _ x _) . (\\x -> AnnDocSection  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . any _ . enumFromThen _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . all _ . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnDocCommentNamed . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . any _ . divMod _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . isAtomicHsExpr . (\\x -> HsBinTick _ x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> shows  x _) . (\\x -> mkSrcLoc _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . any _ . (\\x -> quotRem  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . replicateM_ _ . enumFromThenTo _ _) . sequence\n(fmap . fmap) (ml_hi_file . (\\x -> ModLocation _ x _) . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . all _ . (\\x -> readsPrec  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . userError . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnDocOptionsOld . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) (unlines . fmap (\\x -> showsPrec  x _ _) . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . any _ . (\\x -> take  x _)) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . PprPanic _ . (\\x -> pprTransStmt _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . spans _ . (\\x -> quotRem  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . foldMap _ . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . sum . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . all _ . enumFromThen _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . sum . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . (\\x -> PprSorry  x _) . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . UsageError . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnDocCommentNext . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . foldMap _ . quotRem _) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . PprProgramError _ . (\\x -> pprTransStmt _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . (\\x -> PprSorry  x _) . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . foldMap _ . enumFromThen _) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . sum . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . any _ . (\\x -> take  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . replicateM_ _ . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnBlockComment . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . spans _ . (\\x -> quotRem  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> shows  x _) . mkSrcLoc _ _) . sequence\n(fmap . fmap) (unwords . fmap (\\x -> showsPrec  x _ _) . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . null . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . isQuietHsExpr . (\\x -> HsBinTick  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . srcLocSpan . mkSrcLoc _ _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . any _ . (\\x -> drop  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnLineComment . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . any _ . (\\x -> splitAt  x _)) . sequence\n(fmap . fmap) (ml_obj_file . (\\x -> ModLocation _ x _) . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . (\\x -> PhaseFailed  x _) . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . all _ . divMod _) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . sum . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . ProgramError . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromThenTo _ x _) . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (\\x -> mkSrcLoc _ x _) . enumFromThen _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . foldMap _ . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . all _ . (\\x -> readsPrec  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (\\x -> mkSrcLoc _ x _) . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) (unwords . fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (mkSrcLoc _ _) . enumFromTo _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . (\\x -> mkSrcSpan  x _) . (\\x -> mkSrcLoc _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnDocCommentNext . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . isQuietHsExpr . (\\x -> HsBinTick  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . read . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . any _ . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . AnnDocSection _ . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . any _ . (\\x -> drop  x _)) . sequence\n(fmap . fmap) (ml_obj_file . ModLocation _ _ . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnDocCommentPrev . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) (unlines . fmap (\\x -> showsPrec  x _ _) . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) (ml_hi_file . ModLocation _ _ . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . (\\x -> PprPanic  x _) . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . srcLocSpan . (\\x -> mkSrcLoc _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . foldMap _ . enumFromTo _) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . (\\x -> PprSorry  x _) . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . PprPanic _ . pp_rhs _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . null . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . isAtomicHsExpr . (\\x -> HsBinTick  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . any _ . (\\x -> splitAt  x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . all _ . (\\x -> splitAt  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showList  x _) . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . all _ . (\\x -> drop  x _)) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . (\\x -> PhaseFailed  x _) . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . all _ . (\\x -> quotRem  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . any _ . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (\\x -> scaleFloat  x _) . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showList  x _) . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (\\x -> AnnDocSection  x _) . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . (\\x -> PprProgramError  x _) . (\\x -> shows  x _)) . sequence\n(fmap . fmap) (ml_obj_file . (\\x -> ModLocation _ x _) . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . (\\x -> mkSrcSpan  x _) . mkSrcLoc _ _) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . any _ . enumFromTo _) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . (\\x -> PprProgramError  x _) . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . all _ . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (encodeFloat _) . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . foldMap _ . (\\x -> splitAt  x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . spans _ . quotRem _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . ProgramError . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) (unlines . fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (encodeFloat _) . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . any _ . enumFromTo _) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . any _ . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . Panic . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . all _ . (\\x -> quotRem  x _)) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . (\\x -> PprSorry  x _) . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . any _ . (\\x -> readsPrec  x _)) . sequence\n(fmap . fmap) (unwords . fmap (\\x -> showsPrec  x _ _) . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromThenTo _ x _) . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showList  x _) . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnDocCommentPrev . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . Sorry . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . foldMap _ . divMod _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . length . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . hsExprNeedsParens . (\\x -> HsBinTick _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . (\\x -> PhaseFailed  x _) . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . all _ . (\\x -> take  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . foldMap _ . (\\x -> take  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . (\\x -> PprProgramError  x _) . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . all _ . quotRem _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showsPrec _ x _) . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnDocOptionsOld . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . enumFromThenTo _ _ . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . isQuietHsExpr . (\\x -> HsBinTick _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . PprProgramError _ . pp_rhs _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . InstallationError . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . all _ . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromThenTo  x _ _) . (\\x -> scaleFloat  x _)) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . (\\x -> PprProgramError  x _) . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . mkSrcSpan _ . (\\x -> mkSrcLoc _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . Sorry . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . (\\x -> PprSorry  x _) . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . isQuietHsExpr . (\\x -> HsBinTick _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . all _ . (\\x -> enumFromTo  x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . any _ . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec  x _ _) . length . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnBlockComment . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> enumFromThenTo  x _ _) . encodeFloat _) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . (\\x -> PprPanic  x _) . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . hsExprNeedsParens . (\\x -> HsBinTick _ x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . foldMap _ . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . InstallationError . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . any _ . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . spans _ . divMod _) . sequence\n(fmap . fmap) ((\\x -> showGhcException  x _) . (\\x -> PprProgramError  x _) . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . any _ . (\\x -> readsPrec  x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (mkSrcLoc _ _) . (\\x -> enumFromThen  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . foldMap _ . (\\x -> replicate  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . CmdLineError . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . isAtomicHsExpr . (\\x -> HsBinTick _ x _)) . sequence\n(fmap . fmap) (unlines . fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (\\x -> mkSrcLoc _ x _) . enumFromTo _) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . all _ . (\\x -> replicate  x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . (\\x -> PhaseFailed  x _) . (\\x -> showsPrec _ x _)) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThen  x _)) . setBreakOff _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _) . any _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _)) . print . any _\nfmap (fmap (\\x -> showsPrec _ x _) . replicateM_ _ . enumFromThenTo _ _) . sequence_\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo _ x _)) . setBreakOn _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _)) . sequence_ . fmap (replicateM _)\nfmap (fmap (\\x -> showParen  x _ _) . (\\x -> enumFromThenTo _ x _) . any _) . sequence\n(fmap . fmap) (\\x -> showsPrec _ x _) . replicateM _ . setBreakOn _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThen _) . setBreakOff _ _ . length\nfmap (fmap ((\\x -> showList  x _) . (\\x -> enumFromThenTo  x _ _)) . enumFromThenTo _ _) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _) . any _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _)) . replicateM_ _ . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _) . replicateM_ _ . sequence\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo  x _ _)) . setBreakOn _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _)) . replicateM_ _ . sequence\nfmap (fmap (\\x -> showParen  x _ _) . (\\x -> enumFromThen  x _)) . setBreakOn _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _) . replicateM_ _ . sequence_\nfmap (fmap (\\x -> showParen  x _ _) . (\\x -> enumFromThenTo _ x _) . all _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _)) . replicateM_ _ . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThen  x _)) . setBreakOn _ _ . length\nfmap (fmap (\\x -> showParen  x _ _) . (\\x -> enumFromThenTo  x _ _) . all _) . sequence\n(fmap . fmap) (\\x -> showsPrec _ x _) . replicateM _ . setBreakOff _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThen _) . setBreakOn _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _) . sequence_ . fmap (replicateM_ _)\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo _ x _)) . setBreakOff _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _) . print . all _\nfmap (fmap ((\\x -> showList  x _) . (\\x -> enumFromThenTo _ x _)) . (\\x -> enumFromThenTo  x _ _)) . sequence_\nfmap (fmap ((\\x -> showList  x _) . enumFromThenTo _ _) . enumFromThenTo _ _) . sequence_\nfmap (fmap (\\x -> shows  x _) . enumFromThenTo _ _) . setBreakOff _ _ . length\nfmap (fmap ((\\x -> showList  x _) . (\\x -> enumFromThenTo _ x _)) . enumFromThenTo _ _) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _)) . replicateM_ _ . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _) . print . any _\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _) . sequence_ . fmap (replicateM _)\n(fmap . fmap) (\\x -> showParen  x _ _) . replicateM _ . setBreakOn _ _ . length\nfmap (fmap (\\x -> showParen  x _ _) . enumFromThen _) . setBreakOff _ _ . length\nfmap (fmap (\\x -> showParen  x _ _) . (\\x -> enumFromTo  x _)) . setBreakOn _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _)) . print . any _\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _)) . sequence_ . fmap (replicateM _)\nfmap (fmap ((\\x -> showList  x _) . (\\x -> enumFromThenTo  x _ _)) . (\\x -> enumFromThenTo _ x _)) . sequence_\nfmap (fmap (\\x -> showParen  x _ _) . enumFromThenTo _ _ . any _) . sequence\nfmap (fmap (\\x -> showParen  x _ _) . enumFromTo _) . setBreakOn _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _) . print . foldMap _\nfmap (fmap (\\x -> showsPrec _ x _) . replicateM_ _ . (\\x -> enumFromThenTo  x _ _)) . sequence_\nfmap (fmap (\\x -> shows  x _) . enumFromThenTo _ _) . setBreakOn _ _ . length\nfmap (fmap ((\\x -> showList  x _) . (\\x -> enumFromThenTo _ x _)) . (\\x -> enumFromThenTo _ x _)) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromTo  x _)) . setBreakOn _ _ . length\nfmap (fmap (\\x -> showParen  x _ _) . enumFromThenTo _ _ . all _) . sequence\nfmap (fmap ((\\x -> showList  x _) . enumFromThenTo _ _) . (\\x -> enumFromThenTo _ x _)) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _)) . print . foldMap _\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromTo _) . setBreakOn _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _ . any _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _ . all _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _)) . print . all _\nfmap (fmap (\\x -> showParen  x _ _) . enumFromThen _) . setBreakOn _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _)) . sequence_ . fmap (replicateM_ _)\n(fmap . fmap) (\\x -> showParen  x _ _) . replicateM _ . setBreakOff _ _ . length\nfmap (fmap (\\x -> showParen  x _ _) . (\\x -> enumFromTo  x _)) . setBreakOff _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . replicateM_ _ . zip3 _ _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _) . all _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _) . all _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . replicateM_ _ . (\\x -> enumFromThenTo _ x _)) . sequence_\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromTo  x _)) . setBreakOff _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _)) . print . all _\nfmap (fmap ((\\x -> showList  x _) . (\\x -> enumFromThenTo  x _ _)) . (\\x -> enumFromThenTo  x _ _)) . sequence_\nfmap (fmap (\\x -> showParen  x _ _) . enumFromTo _) . setBreakOff _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _)) . sequence_ . fmap (replicateM_ _)\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _)) . print . foldMap _\nfmap (fmap (\\x -> showParen  x _ _) . (\\x -> enumFromThenTo  x _ _) . any _) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromTo _) . setBreakOff _ _ . length\nfmap (fmap (\\x -> shows  x _) . (\\x -> enumFromThenTo  x _ _)) . setBreakOff _ _ . length\nfmap (fmap (\\x -> showParen  x _ _) . (\\x -> enumFromThen  x _)) . setBreakOff _ _ . length\nfmap (fmap ((\\x -> showList  x _) . enumFromThenTo _ _) . (\\x -> enumFromThenTo  x _ _)) . sequence_\n(fmap . fmap) ((\\x -> showParen  x _ _) . any _ . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (mkSrcLoc _ _) . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . mkSrcSpan _ . mkSrcLoc _ _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . any _ . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . (\\x -> PprSorry  x _) . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (mkSrcLoc _ _) . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . any _ . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . all _ . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . ModLocation _ _ . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . all _ . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . (\\x -> ModLocation _ x _) . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . any _ . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . PprProgramError _ . (\\x -> pprTransStmt _ x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showsPrec _ x _) . mkSrcLoc _ _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . foldMap _ . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (\\x -> mkSrcLoc _ x _) . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . PprPanic _ . (\\x -> pprTransStmt _ x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . ModLocation _ _ . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . all _ . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnDocSection _ . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . (\\x -> PprPanic  x _) . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . (\\x -> PprProgramError  x _) . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . (\\x -> PprSorry  x _) . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . foldMap _ . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . any _ . (\\x -> enumFromThenTo _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . (\\x -> PhaseFailed  x _) . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . (\\x -> ModLocation _ x _) . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . (\\x -> ModLocation _ x _) . (\\x -> shows  x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . all _ . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . (\\x -> mkSrcSpan  x _) . (\\x -> mkSrcLoc _ x _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (mkSrcLoc _ _) . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . any _ . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . (\\x -> showsPrec _ x _) . (\\x -> mkSrcLoc _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . (\\x -> PhaseFailed  x _) . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . (\\x -> mkSrcSpan  x _) . mkSrcLoc _ _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . all _ . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> shows  x _) . ModLocation _ _ . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . AnnDocSection _ . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . (\\x -> PprProgramError  x _) . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (\\x -> mkSrcLoc _ x _) . (\\x -> enumFromThenTo  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . mkSrcSpan _ . (\\x -> mkSrcLoc _ x _)) . sequence\n(fmap . fmap) ((\\x -> showParen  x _ _) . all _ . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showList  x _) . fmap (\\x -> mkSrcLoc _ x _) . enumFromThenTo _ _) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . PprSorry _ . (\\x -> pprTransStmt _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . (\\x -> PprPanic  x _) . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . foldMap _ . (\\x -> enumFromThenTo _ x _)) . sequence\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _)) . setBreakOn _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _) . setBreakOn _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . enumFromThenTo _ _) . setBreakOff _ _ . length\nfmap (fmap (\\x -> showParen  x _ _) . enumFromThenTo _ _) . setBreakOn _ _ . length\nfmap (fmap (\\x -> showParen  x _ _) . (\\x -> enumFromThenTo  x _ _)) . setBreakOn _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _)) . setBreakOn _ _ . length\nfmap (fmap (\\x -> showParen  x _ _) . (\\x -> enumFromThenTo _ x _)) . setBreakOff _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo _ x _)) . setBreakOff _ _ . length\nfmap (fmap (\\x -> showParen  x _ _) . enumFromThenTo _ _) . setBreakOff _ _ . length\nfmap (fmap (\\x -> showParen  x _ _) . (\\x -> enumFromThenTo  x _ _)) . setBreakOff _ _ . length\nfmap (fmap (\\x -> showsPrec _ x _) . (\\x -> enumFromThenTo  x _ _)) . setBreakOff _ _ . length\nfmap (fmap (\\x -> showParen  x _ _) . (\\x -> enumFromThenTo _ x _)) . setBreakOn _ _ . length\n(fmap . fmap) ((\\x -> showsPrec _ x _) . (\\x -> ModLocation _ x _) . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . ModLocation _ _ . (\\x -> showsPrec  x _ _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . (\\x -> ModLocation _ x _) . (\\x -> showsPrec _ x _)) . sequence\n(fmap . fmap) ((\\x -> showsPrec _ x _) . ModLocation _ _ . (\\x -> showsPrec _ x _)) . sequence\n"
Got: Load "/home/izzy/prog/slick/Search/Graph.hs"
These be the argHoles:fromList []
Giving: Error "GHC error: Mote.Holes.getHoleInfos: Non type-variable argument\n  in the constraint: MArray\n                       a (Map k_aIvC (HashSet.HashSet [a_aIvD])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i, MArray a (Map k0 (HashSet.HashSet [a0])) f) =>\n        a i (Map k0 (HashSet.HashSet [a0]))\n        -> i -> k0 -> f (HashSet.HashSet [a0])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo'\8217:\n    moveSequencesOfSizeAtMostMemo' branchOut n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet [Move f o])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray a (Map (Word f o) (HashSet.HashSet [Move f o])) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet [Move f o]))\n        -> i -> Word f o -> f1 (HashSet.HashSet [Move f o])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo\8217:\n    moveSequencesOfSizeAtMostMemo tsList n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMost\8217:\n    graphsOfSizeAtMost tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i\n        -> Word f o\n        -> Trans f o\n        -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostH\8217:\n    graphsOfSizeAtMostH tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 fmap HashSet.unions . forM (branchOut ts start)\n                 $ \\ (b', move) -> ... }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go _ 0 b _\n            = return\n              $ if b == end then\n                    HashSet.singleton (idGraph end)\n                else\n                    HashSet.empty\n          go arr n b t\n            = do { memo <- readArray arr n;\n                   .... }"
Got: Load "/home/izzy/prog/slick/Search/Graph.hs"
These be the argHoles:fromList []
Giving: Error "GHC error: Mote.Holes.getHoleInfos: Non type-variable argument\n  in the constraint: MArray\n                       a (Map k_aPvL (HashSet.HashSet [a_aPvM])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i, MArray a (Map k0 (HashSet.HashSet [a0])) f) =>\n        a i (Map k0 (HashSet.HashSet [a0]))\n        -> i -> k0 -> f (HashSet.HashSet [a0])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo'\8217:\n    moveSequencesOfSizeAtMostMemo' branchOut n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet [Move f o])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray a (Map (Word f o) (HashSet.HashSet [Move f o])) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet [Move f o]))\n        -> i -> Word f o -> f1 (HashSet.HashSet [Move f o])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo\8217:\n    moveSequencesOfSizeAtMostMemo tsList n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMost\8217:\n    graphsOfSizeAtMost tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i\n        -> Word f o\n        -> Trans f o\n        -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostH\8217:\n    graphsOfSizeAtMostH tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 fmap HashSet.unions . forM (branchOut ts start)\n                 $ \\ (b', move) -> ... }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go _ 0 b _\n            = return\n              $ if b == end then\n                    HashSet.singleton (idGraph end)\n                else\n                    HashSet.empty\n          go arr n b t\n            = do { memo <- readArray arr n;\n                   .... }"
Got: Load "/home/izzy/prog/slick/Search/Graph.hs"
Giving: Error "GHC error: /home/izzy/prog/slick/Search/Graph.hs:571:1:\n    The type signature for \8216graphsOfSizeAtMostMemo'\8217\n      lacks an accompanying binding\n/home/izzy/prog/slick/Search/Graph.hs:612:1:\n    Multiple declarations of \8216graphsOfSizeAtMost\8217\n    Declared at: /home/izzy/prog/slick/Search/Graph.hs:578:1\n                 /home/izzy/prog/slick/Search/Graph.hs:612:1\n"
Got: Load "/home/izzy/prog/slick/Search/Graph.hs"
These be the argHoles:fromList []
Giving: Error "GHC error: Mote.Holes.getHoleInfos: Non type-variable argument\n  in the constraint: MArray\n                       a (Map k_aWTE (HashSet.HashSet [a_aWTF])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i, MArray a (Map k0 (HashSet.HashSet [a0])) f) =>\n        a i (Map k0 (HashSet.HashSet [a0]))\n        -> i -> k0 -> f (HashSet.HashSet [a0])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo'\8217:\n    moveSequencesOfSizeAtMostMemo' branchOut n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet [Move f o])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray a (Map (Word f o) (HashSet.HashSet [Move f o])) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet [Move f o]))\n        -> i -> Word f o -> f1 (HashSet.HashSet [Move f o])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo\8217:\n    moveSequencesOfSizeAtMostMemo tsList n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostMemo'\8217:\n    graphsOfSizeAtMostMemo' tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMost\8217:\n    graphsOfSizeAtMost tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i\n        -> Word f o\n        -> Trans f o\n        -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostH\8217:\n    graphsOfSizeAtMostH tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 fmap HashSet.unions . forM (branchOut ts start)\n                 $ \\ (b', move) -> ... }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go _ 0 b _\n            = return\n              $ if b == end then\n                    HashSet.singleton (idGraph end)\n                else\n                    HashSet.empty\n          go arr n b t\n            = do { memo <- readArray arr n;\n                   .... }"
Got: Load "/home/izzy/prog/slick/Search/Graph.hs"
These be the argHoles:fromList []
Giving: Error "GHC error: Mote.Holes.getHoleInfos: Non type-variable argument\n  in the constraint: MArray\n                       a (Map k_a14dS (HashSet.HashSet [a_a14dT])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i, MArray a (Map k0 (HashSet.HashSet [a0])) f) =>\n        a i (Map k0 (HashSet.HashSet [a0]))\n        -> i -> k0 -> f (HashSet.HashSet [a0])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo'\8217:\n    moveSequencesOfSizeAtMostMemo' branchOut n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet [Move f o])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray a (Map (Word f o) (HashSet.HashSet [Move f o])) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet [Move f o]))\n        -> i -> Word f o -> f1 (HashSet.HashSet [Move f o])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo\8217:\n    moveSequencesOfSizeAtMostMemo tsList n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMost\8217:\n    graphsOfSizeAtMost tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i\n        -> Word f o\n        -> Trans f o\n        -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostH\8217:\n    graphsOfSizeAtMostH tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 fmap HashSet.unions . forM (branchOut ts start)\n                 $ \\ (b', move) -> ... }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go _ 0 b _\n            = return\n              $ if b == end then\n                    HashSet.singleton (idGraph end)\n                else\n                    HashSet.empty\n          go arr n b t\n            = do { memo <- readArray arr n;\n                   .... }"
Got: Load "/home/izzy/prog/slick/Search/Graph.hs"
These be the argHoles:fromList []
Giving: Error "GHC error: Mote.Holes.getHoleInfos: Non type-variable argument\n  in the constraint: MArray\n                       a (Map k_a1bzq (HashSet.HashSet [a_a1bzr])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i, MArray a (Map k0 (HashSet.HashSet [a0])) f) =>\n        a i (Map k0 (HashSet.HashSet [a0]))\n        -> i -> k0 -> f (HashSet.HashSet [a0])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo'\8217:\n    moveSequencesOfSizeAtMostMemo' branchOut n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet [Move f o])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray a (Map (Word f o) (HashSet.HashSet [Move f o])) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet [Move f o]))\n        -> i -> Word f o -> f1 (HashSet.HashSet [Move f o])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo\8217:\n    moveSequencesOfSizeAtMostMemo tsList n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostMemo'\8217:\n    graphsOfSizeAtMostMemo' branchOut n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMost\8217:\n    graphsOfSizeAtMost tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i\n        -> Word f o\n        -> Trans f o\n        -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostH\8217:\n    graphsOfSizeAtMostH tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 fmap HashSet.unions . forM (branchOut ts start)\n                 $ \\ (b', move) -> ... }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go _ 0 b _\n            = return\n              $ if b == end then\n                    HashSet.singleton (idGraph end)\n                else\n                    HashSet.empty\n          go arr n b t\n            = do { memo <- readArray arr n;\n                   .... }"
Got: Load "/home/izzy/prog/slick/Search/Graph.hs"
Giving: Error "GHC error: /home/izzy/prog/slick/Search/Graph.hs:578:1:\n    parse error (possibly incorrect indentation or mismatched brackets)\n"
Got: Load "/home/izzy/prog/slick/Search/Graph.hs"
These be the argHoles:fromList []
Giving: Error "GHC error: Mote.Holes.getHoleInfos: Non type-variable argument\n  in the constraint: MArray\n                       a (Map k_a1iUq (HashSet.HashSet [a_a1iUr])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i, MArray a (Map k0 (HashSet.HashSet [a0])) f) =>\n        a i (Map k0 (HashSet.HashSet [a0]))\n        -> i -> k0 -> f (HashSet.HashSet [a0])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo'\8217:\n    moveSequencesOfSizeAtMostMemo' branchOut n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet [Move f o])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray a (Map (Word f o) (HashSet.HashSet [Move f o])) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet [Move f o]))\n        -> i -> Word f o -> f1 (HashSet.HashSet [Move f o])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo\8217:\n    moveSequencesOfSizeAtMostMemo tsList n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMost\8217:\n    graphsOfSizeAtMost tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i\n        -> Word f o\n        -> Trans f o\n        -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostH\8217:\n    graphsOfSizeAtMostH tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 fmap HashSet.unions . forM (branchOut ts start)\n                 $ \\ (b', move) -> ... }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go _ 0 b _\n            = return\n              $ if b == end then\n                    HashSet.singleton (idGraph end)\n                else\n                    HashSet.empty\n          go arr n b t\n            = do { memo <- readArray arr n;\n                   .... }"
Got: Load "/home/izzy/prog/slick/Search/Graph.hs"
These be the argHoles:fromList []
Giving: Error "GHC error: Mote.Holes.getHoleInfos: Non type-variable argument\n  in the constraint: MArray\n                       a (Map k_a1qf1 (HashSet.HashSet [a_a1qf2])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i, MArray a (Map k0 (HashSet.HashSet [a0])) f) =>\n        a i (Map k0 (HashSet.HashSet [a0]))\n        -> i -> k0 -> f (HashSet.HashSet [a0])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo'\8217:\n    moveSequencesOfSizeAtMostMemo' branchOut n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet [Move f o])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray a (Map (Word f o) (HashSet.HashSet [Move f o])) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet [Move f o]))\n        -> i -> Word f o -> f1 (HashSet.HashSet [Move f o])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo\8217:\n    moveSequencesOfSizeAtMostMemo tsList n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMost\8217:\n    graphsOfSizeAtMost tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i\n        -> Word f o\n        -> Trans f o\n        -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostH\8217:\n    graphsOfSizeAtMostH tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 fmap HashSet.unions . forM (branchOut ts start)\n                 $ \\ (b', move) -> ... }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go _ 0 b _\n            = return\n              $ if b == end then\n                    HashSet.singleton (idGraph end)\n                else\n                    HashSet.empty\n          go arr n b t\n            = do { memo <- readArray arr n;\n                   .... }"
Got: Load "/home/izzy/prog/slick/Search/Graph.hs"
These be the argHoles:fromList []
Giving: Error "GHC error: Mote.Holes.getHoleInfos: Non type-variable argument\n  in the constraint: MArray\n                       a (Map k_a1xzt (HashSet.HashSet [a_a1xzu])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i, MArray a (Map k0 (HashSet.HashSet [a0])) f) =>\n        a i (Map k0 (HashSet.HashSet [a0]))\n        -> i -> k0 -> f (HashSet.HashSet [a0])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo'\8217:\n    moveSequencesOfSizeAtMostMemo' branchOut n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet [Move f o])) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray a (Map (Word f o) (HashSet.HashSet [Move f o])) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet [Move f o]))\n        -> i -> Word f o -> f1 (HashSet.HashSet [Move f o])\nIn an equation for \8216moveSequencesOfSizeAtMostMemo\8217:\n    moveSequencesOfSizeAtMostMemo tsList n start end\n      = HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton [])\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostMemo'\8217:\n    graphsOfSizeAtMostMemo' branchOut n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i -> Word f o -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMost\8217:\n    graphsOfSizeAtMost tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 go arr n start }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go arr n b\n            | b == end = return (HashSet.singleton (idGraph end))\n            | n == 0 = return HashSet.empty\n            | otherwise\n            = do { memo <- readArray arr n;\n                   .... }\nNon type-variable argument\n  in the constraint: MArray\n                       a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f\n(Use FlexibleContexts to permit this)\nWhen checking that \8216go\8217 has the inferred type\n  go :: forall (f1 :: * -> *) (a :: * -> * -> *) i.\n        (Num i, Ix i,\n         MArray\n           a (Map (Word f o) (HashSet.HashSet (NaturalGraph f o))) f1) =>\n        a i (Map (Word f o) (HashSet.HashSet (NaturalGraph f o)))\n        -> i\n        -> Word f o\n        -> Trans f o\n        -> f1 (HashSet.HashSet (NaturalGraph f o))\nIn an equation for \8216graphsOfSizeAtMostH\8217:\n    graphsOfSizeAtMostH tsList n start end\n      = map deleteStrayVertices . HashSet.toList\n        $ runST\n          $ do { arr <- newSTArray (0, n) Map.empty;\n                 fmap HashSet.unions . forM (branchOut ts start)\n                 $ \\ (b', move) -> ... }\n      where\n          newSTArray ::\n            (Int, Int) -> Map k v -> ST s (STArray s Int (Map k v))\n          newSTArray = newArray\n          ts\n            = HashMap.fromListWith (++) (map (\\ t -> (from t, [...])) tsList)\n          go _ 0 b _\n            = return\n              $ if b == end then\n                    HashSet.singleton (idGraph end)\n                else\n                    HashSet.empty\n          go arr n b t\n            = do { memo <- readArray arr n;\n                   .... }"
Got: SendStop
Giving: Stop
